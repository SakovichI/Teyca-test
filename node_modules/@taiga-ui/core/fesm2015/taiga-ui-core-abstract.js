import * as i0 from '@angular/core';
import { Directive, Self, Inject, SkipSelf, Optional } from '@angular/core';
import { TuiDestroyService, AbstractTuiControl } from '@taiga-ui/cdk';
import * as i1 from 'rxjs';
import { Observable, merge } from 'rxjs';
import { distinctUntilChanged, takeUntil } from 'rxjs/operators';

// eslint-disable-next-line @typescript-eslint/naming-convention
class TuiDriver extends Observable {
}
function tuiAsDriver(useExisting) {
    return {
        provide: TuiDriver,
        multi: true,
        useExisting,
    };
}

// eslint-disable-next-line @typescript-eslint/naming-convention
class TuiVehicle {
}
function tuiAsVehicle(useExisting) {
    return {
        provide: TuiVehicle,
        multi: true,
        useExisting,
    };
}

class AbstractTuiDriverDirective {
    constructor(destroy$, drivers, vehicles) {
        this.destroy$ = destroy$;
        this.drivers = drivers;
        this.vehicles = vehicles;
    }
    ngOnInit() {
        const vehicle = this.vehicles.find(({ type }) => type === this.type);
        merge(...this.drivers.filter(({ type }) => type === this.type))
            .pipe(distinctUntilChanged(), takeUntil(this.destroy$))
            .subscribe(value => {
            vehicle === null || vehicle === void 0 ? void 0 : vehicle.toggle(value);
        });
    }
}
AbstractTuiDriverDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiDriverDirective, deps: [{ token: TuiDestroyService, self: true }, { token: TuiDriver }, { token: TuiVehicle }], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiDriverDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiDriverDirective, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiDriverDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TuiDriver]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TuiVehicle]
                }] }]; } });

class AbstractTuiTextfieldHost {
    constructor(host) {
        this.host = host;
    }
    get readOnly() {
        return this.host.readOnly;
    }
    get disabled() {
        return this.host.computedDisabled;
    }
    get invalid() {
        return this.host.computedInvalid;
    }
    get focusable() {
        return this.host.computedFocusable;
    }
    get inputMode() {
        return 'text';
    }
    get value() {
        var _a;
        return ((_a = this.host.value) === null || _a === void 0 ? void 0 : _a.toString()) || '';
    }
    process(_input) { }
}
AbstractTuiTextfieldHost.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiTextfieldHost, deps: [{ token: AbstractTuiControl }], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiTextfieldHost.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiTextfieldHost, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiTextfieldHost, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [AbstractTuiControl]
                }] }]; } });

// TODO: Drop any
function tuiFallbackAccessor(type) {
    return (accessors, fallback) => (accessors === null || accessors === void 0 ? void 0 : accessors.find(accessor => accessor !== fallback && accessor.type === type)) ||
        fallback;
}

// eslint-disable-next-line @typescript-eslint/naming-convention
class TuiPositionAccessor {
}
// TODO: Make fallback required
function tuiPositionAccessorFor(type, fallback) {
    return {
        provide: TuiPositionAccessor,
        deps: fallback
            ? [[new SkipSelf(), new Optional(), TuiPositionAccessor], fallback]
            : [[new SkipSelf(), new Optional(), TuiPositionAccessor]],
        useFactory: tuiFallbackAccessor(type),
    };
}
function tuiAsPositionAccessor(useExisting) {
    return {
        provide: TuiPositionAccessor,
        multi: true,
        useExisting,
    };
}

// TODO: Rename to getBoundingClientRect to match the DOM API
// eslint-disable-next-line @typescript-eslint/naming-convention
class TuiRectAccessor {
}
function tuiRectAccessorFor(type, fallback) {
    return {
        provide: TuiRectAccessor,
        deps: [[new SkipSelf(), new Optional(), TuiRectAccessor], fallback],
        useFactory: tuiFallbackAccessor(type),
    };
}
const tuiFallbackRectAccessor = tuiFallbackAccessor;
function tuiAsRectAccessor(useExisting) {
    return {
        provide: TuiRectAccessor,
        multi: true,
        useExisting,
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiDriverDirective, AbstractTuiTextfieldHost, TuiDriver, TuiPositionAccessor, TuiRectAccessor, TuiVehicle, tuiAsDriver, tuiAsPositionAccessor, tuiAsRectAccessor, tuiAsVehicle, tuiFallbackAccessor, tuiFallbackRectAccessor, tuiPositionAccessorFor, tuiRectAccessorFor };
//# sourceMappingURL=taiga-ui-core-abstract.js.map
