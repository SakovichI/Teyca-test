import { tuiAssert } from '@taiga-ui/cdk/classes';
import { TuiDayOfWeek, TuiMonthNumber } from '@taiga-ui/cdk/enums';
import { TuiInvalidDayException, TuiInvalidMonthException, TuiInvalidYearException, } from '@taiga-ui/cdk/exceptions';
import { tuiInRange, tuiNormalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DATE_FILLER_LENGTH } from './date-fillers';
import { MIN_DAY, MONTHS_IN_YEAR } from './date-time';
import { TuiMonth } from './month';
import { TuiYear } from './year';
// TODO: Localized formatting
/**
 * Immutable date object, consisting of day, month and year
 */
export class TuiDay extends TuiMonth {
    constructor(year, month, day) {
        super(year, month);
        this.day = day;
        ngDevMode && tuiAssert.assert(TuiDay.isValidDay(year, month, day));
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    static fromLocalNativeDate(date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    static fromUtcNativeDate(date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    }
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    static isValidDay(year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    }
    /**
     * Current day based on local time zone
     */
    static currentLocal() {
        const nativeDate = new Date();
        const year = nativeDate.getFullYear();
        const month = nativeDate.getMonth();
        const day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Returns current day based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        const year = nativeDate.getUTCFullYear();
        const month = nativeDate.getUTCMonth();
        const day = nativeDate.getUTCDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    static normalizeOf(year, month, day) {
        const normalizedYear = TuiYear.normalizeYearPart(year);
        const normalizedMonth = TuiMonth.normalizeMonthPart(month);
        const normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    }
    static lengthBetween(from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    }
    static parseRawDateString(date, dateMode = 'DMY') {
        ngDevMode &&
            tuiAssert.assert(date.length === DATE_FILLER_LENGTH, '[parseRawDateString]: wrong date string length');
        switch (dateMode) {
            case 'YMD':
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case 'MDY':
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            case 'DMY':
            default:
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    }
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    static normalizeParse(rawDate, dateMode = 'DMY') {
        const { day, month, year } = this.parseRawDateString(rawDate, dateMode);
        return TuiDay.normalizeOf(year, month, day);
    }
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    static jsonParse(yearMonthDayString) {
        const { day, month, year } = this.parseRawDateString(yearMonthDayString, 'YMD');
        if (!TuiYear.isValidYear(year)) {
            throw new TuiInvalidYearException(year);
        }
        if (!TuiMonth.isValidMonth(year, month)) {
            throw new TuiInvalidMonthException(month);
        }
        if (!Number.isInteger(day) ||
            !tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new TuiInvalidDayException(day);
        }
        return new TuiDay(year, month, day);
    }
    static normalizeDayPart(day, month, year) {
        ngDevMode && tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        const monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return tuiNormalizeToIntNumber(day, 1, monthDaysCount);
    }
    get formattedDayPart() {
        return String(this.day).padStart(2, '0');
    }
    get isWeekend() {
        const dayOfWeek = this.dayOfWeek(false);
        return dayOfWeek === TuiDayOfWeek.Saturday || dayOfWeek === TuiDayOfWeek.Sunday;
    }
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    dayOfWeek(startFromMonday = true) {
        const dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    }
    /**
     * Passed date is after current
     */
    dayBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    }
    /**
     * Passed date is after or equals to current
     */
    daySameOrBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    }
    /**
     * Passed date is the same as current
     */
    daySame(another) {
        return this.monthSame(another) && this.day === another.day;
    }
    /**
     * Passed date is either before or the same as current
     */
    daySameOrAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    }
    /**
     * Passed date is before current
     */
    dayAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    }
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    dayLimit(min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    }
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @return new date object as a result of offsetting current
     */
    append({ year = 0, month = 0, day = 0 }) {
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        let years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        let months = totalMonths % MONTHS_IN_YEAR;
        let days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === TuiMonthNumber.December) {
                years++;
                months = TuiMonthNumber.January;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === TuiMonthNumber.January) {
                years--;
                months = TuiMonthNumber.December;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    }
    /**
     * Returns formatted whole date
     */
    getFormattedDay(dateFormat, separator) {
        ngDevMode &&
            tuiAssert.assert(separator.length === 1, 'Separator should consist of only 1 symbol');
        const dd = this.formattedDayPart;
        const mm = this.formattedMonthPart;
        const yyyy = this.formattedYear;
        switch (dateFormat) {
            case 'YMD':
                return `${yyyy}${separator}${mm}${separator}${dd}`;
            case 'MDY':
                return `${mm}${separator}${dd}${separator}${yyyy}`;
            case 'DMY':
            default:
                return `${dd}${separator}${mm}${separator}${yyyy}`;
        }
    }
    toString(dateFormat = 'DMY', separator = '.') {
        return this.getFormattedDay(dateFormat, separator);
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedDayPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        var _a;
        const date = new Date(this.year, this.month, this.day);
        // needed for years less than 1900
        date.setFullYear(Number((_a = this.year) !== null && _a !== void 0 ? _a : '0'));
        return date;
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month, this.day));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2RhdGUtdGltZS9kYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2hELE9BQU8sRUFBQyxZQUFZLEVBQUUsY0FBYyxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDakUsT0FBTyxFQUNILHNCQUFzQixFQUN0Qix3QkFBd0IsRUFDeEIsdUJBQXVCLEdBQzFCLE1BQU0sMEJBQTBCLENBQUM7QUFHbEMsT0FBTyxFQUFDLFVBQVUsRUFBRSx1QkFBdUIsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBRTdFLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ2xELE9BQU8sRUFBQyxPQUFPLEVBQUUsY0FBYyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ3BELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDakMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUUvQiw2QkFBNkI7QUFDN0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sTUFBTyxTQUFRLFFBQVE7SUFDaEMsWUFDSSxJQUFZLEVBQ1osS0FBYSxFQUNKLEdBQVc7UUFFcEIsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUZWLFFBQUcsR0FBSCxHQUFHLENBQVE7UUFHcEIsU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLG1CQUFtQixDQUFDLElBQVU7UUFDakMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFB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QztTQUMxRDtJQUNMLENBQUM7SUFFUSxRQUFRLENBQUMsYUFBMEIsS0FBSyxFQUFFLFlBQW9CLEdBQUc7UUFDdEUsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRVEsTUFBTTtRQUNYLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDeEQsQ0FBQztJQUVEOztPQUVHO0lBQ00saUJBQWlCOztRQUN0QixNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXZELGtDQUFrQztRQUNsQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFBLElBQUksQ0FBQyxJQUFJLG1DQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFM0MsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOztPQUVHO0lBQ00sZUFBZTtRQUNwQixPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dHVpQXNzZXJ0fSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NsYXNzZXMnO1xuaW1wb3J0IHtUdWlEYXlPZldlZWssIFR1aU1vbnRoTnVtYmVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2VudW1zJztcbmltcG9ydCB7XG4gICAgVHVpSW52YWxpZERheUV4Y2VwdGlvbixcbiAgICBUdWlJbnZhbGlkTW9udGhFeGNlcHRpb24sXG4gICAgVHVpSW52YWxpZFllYXJFeGNlcHRpb24sXG59IGZyb20gJ0B0YWlnYS11aS9jZGsvZXhjZXB0aW9ucyc7XG5pbXBvcnQge1R1aURheUxpa2V9IGZyb20gJ0B0YWlnYS11aS9jZGsvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1R1aURhdGVNb2RlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3R5cGVzJztcbmltcG9ydCB7dHVpSW5SYW5nZSwgdHVpTm9ybWFsaXplVG9JbnROdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvbWF0aCc7XG5cbmltcG9ydCB7REFURV9GSUxMRVJfTEVOR1RIfSBmcm9tICcuL2RhdGUtZmlsbGVycyc7XG5pbXBvcnQge01JTl9EQVksIE1PTlRIU19JTl9ZRUFSfSBmcm9tICcuL2RhdGUtdGltZSc7XG5pbXBvcnQge1R1aU1vbnRofSBmcm9tICcuL21vbnRoJztcbmltcG9ydCB7VHVpWWVhcn0gZnJvbSAnLi95ZWFyJztcblxuLy8gVE9ETzogTG9jYWxpemVkIGZvcm1hdHRpbmdcbi8qKlxuICogSW1tdXRhYmxlIGRhdGUgb2JqZWN0LCBjb25zaXN0aW5nIG9mIGRheSwgbW9udGggYW5kIHllYXJcbiAqL1xuZXhwb3J0IGNsYXNzIFR1aURheSBleHRlbmRzIFR1aU1vbnRoIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgeWVhcjogbnVtYmVyLFxuICAgICAgICBtb250aDogbnVtYmVyLFxuICAgICAgICByZWFkb25seSBkYXk6IG51bWJlcixcbiAgICApIHtcbiAgICAgICAgc3VwZXIoeWVhciwgbW9udGgpO1xuICAgICAgICBuZ0Rldk1vZGUgJiYgdHVpQXNzZXJ0LmFzc2VydChUdWlEYXkuaXNWYWxpZERheSh5ZWFyLCBtb250aCwgZGF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB7QGxpbmsgVHVpRGF5fSBmcm9tIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Mb2NhbE5hdGl2ZURhdGUoZGF0ZTogRGF0ZSk6IFR1aURheSB7XG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB7QGxpbmsgVHVpRGF5fSBmcm9tIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gdXNpbmcgVVRDXG4gICAgICovXG4gICAgc3RhdGljIGZyb21VdGNOYXRpdmVEYXRlKGRhdGU6IERhdGUpOiBUdWlEYXkge1xuICAgICAgICByZXR1cm4gbmV3IFR1aURheShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkaXR5IG9mIHllYXIsIG1vbnRoIGFuZCBkYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoXG4gICAgICogQHBhcmFtIGRheVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB2YWxpZGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkRGF5KHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFR1aU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkgJiZcbiAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoZGF5KSAmJlxuICAgICAgICAgICAgdHVpSW5SYW5nZShcbiAgICAgICAgICAgICAgICBkYXksXG4gICAgICAgICAgICAgICAgTUlOX0RBWSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aCwgVHVpWWVhci5pc0xlYXBZZWFyKHllYXIpKSArIDEsXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkYXkgYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgc3RhdGljIG92ZXJyaWRlIGN1cnJlbnRMb2NhbCgpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgeWVhciA9IG5hdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBuYXRpdmVEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBkYXkgYmFzZWQgb24gVVRDXG4gICAgICovXG4gICAgc3RhdGljIG92ZXJyaWRlIGN1cnJlbnRVdGMoKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3QgbmF0aXZlRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBuYXRpdmVEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gbmF0aXZlRGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICBjb25zdCBkYXkgPSBuYXRpdmVEYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHtAbGluayBUdWlEYXl9IG5vcm1hbGl6aW5nIHllYXIsIG1vbnRoIGFuZCBkYXkuIHtAbGluayBOYU59IGlzIHR1cm5lZCBpbnRvIG1pbmltYWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhciBhbnkgeWVhciB2YWx1ZSwgaW5jbHVkaW5nIGludmFsaWRcbiAgICAgKiBAcGFyYW0gbW9udGggYW55IG1vbnRoIHZhbHVlLCBpbmNsdWRpbmcgaW52YWxpZCAobW9udGhzIHN0YXJ0IHdpdGggMClcbiAgICAgKiBAcGFyYW0gZGF5IGFueSBkYXkgdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIGRhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplT2YoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRZZWFyID0gVHVpWWVhci5ub3JtYWxpemVZZWFyUGFydCh5ZWFyKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE1vbnRoID0gVHVpTW9udGgubm9ybWFsaXplTW9udGhQYXJ0KG1vbnRoKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZERheSA9IFR1aURheS5ub3JtYWxpemVEYXlQYXJ0KFxuICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgbm9ybWFsaXplZE1vbnRoLFxuICAgICAgICAgICAgbm9ybWFsaXplZFllYXIsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkobm9ybWFsaXplZFllYXIsIG5vcm1hbGl6ZWRNb250aCwgbm9ybWFsaXplZERheSk7XG4gICAgfVxuXG4gICAgc3RhdGljIG92ZXJyaWRlIGxlbmd0aEJldHdlZW4oZnJvbTogVHVpRGF5LCB0bzogVHVpRGF5KTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgICAgICAgICAodG8udG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXRUaW1lKCkgLSBmcm9tLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0VGltZSgpKSAvXG4gICAgICAgICAgICAgICAgKDEwMDAgKiA2MCAqIDYwICogMjQpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZVJhd0RhdGVTdHJpbmcoXG4gICAgICAgIGRhdGU6IHN0cmluZyxcbiAgICAgICAgZGF0ZU1vZGU6IFR1aURhdGVNb2RlID0gJ0RNWScsXG4gICAgKToge2RheTogbnVtYmVyOyBtb250aDogbnVtYmVyOyB5ZWFyOiBudW1iZXJ9IHtcbiAgICAgICAgbmdEZXZNb2RlICYmXG4gICAgICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIGRhdGUubGVuZ3RoID09PSBEQVRFX0ZJTExFUl9MRU5HVEgsXG4gICAgICAgICAgICAgICAgJ1twYXJzZVJhd0RhdGVTdHJpbmddOiB3cm9uZyBkYXRlIHN0cmluZyBsZW5ndGgnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGVNb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdZTUQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSg4LCAxMCksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IHBhcnNlSW50KGRhdGUuc2xpY2UoNSwgNyksIDEwKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoMCwgNCksIDEwKSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYXNlICdNRFknOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSgzLCA1KSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBtb250aDogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCAyKSwgMTApIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogcGFyc2VJbnQoZGF0ZS5zbGljZSg2LCAxMCksIDEwKSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYXNlICdETVknOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXk6IHBhcnNlSW50KGRhdGUuc2xpY2UoMCwgMiksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IHBhcnNlSW50KGRhdGUuc2xpY2UoMywgNSksIDEwKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoNiwgMTApLCAxMCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IE1vdmUgbW9udGggYW5kIHllYXIgcmVsYXRlZCBjb2RlIGNvcnJlc3BvbmRpbmcgY2xhc3Nlc1xuICAgIC8qKlxuICAgICAqIFBhcnNpbmcgYSBzdHJpbmcgd2l0aCBkYXRlIHdpdGggbm9ybWFsaXphdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHJhd0RhdGUgZGF0ZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGF0ZU1vZGUgZGF0ZSBmb3JtYXQgb2YgdGhlIGRhdGUgc3RyaW5nIChETVkgfCBNRFkgfCBZTUQpXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIGRhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplUGFyc2UocmF3RGF0ZTogc3RyaW5nLCBkYXRlTW9kZTogVHVpRGF0ZU1vZGUgPSAnRE1ZJyk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IHtkYXksIG1vbnRoLCB5ZWFyfSA9IHRoaXMucGFyc2VSYXdEYXRlU3RyaW5nKHJhd0RhdGUsIGRhdGVNb2RlKTtcblxuICAgICAgICByZXR1cm4gVHVpRGF5Lm5vcm1hbGl6ZU9mKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNpbmcgYSBkYXRlIHN0cmluZ2lmaWVkIGluIGEgdG9KU09OIGZvcm1hdFxuICAgICAqIEBwYXJhbSB5ZWFyTW9udGhEYXlTdHJpbmcgZGF0ZSBzdHJpbmcgaW4gZm9ybWF0IG9mIFlZWVktTU0tRERcbiAgICAgKiBAcmV0dXJuIGRhdGVcbiAgICAgKiBAdGhyb3dzIGV4Y2VwdGlvbnMgaWYgYW55IHBhcnQgb2YgdGhlIGRhdGUgaXMgaW52YWxpZFxuICAgICAqL1xuICAgIHN0YXRpYyBqc29uUGFyc2UoeWVhck1vbnRoRGF5U3RyaW5nOiBzdHJpbmcpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCB7ZGF5LCBtb250aCwgeWVhcn0gPSB0aGlzLnBhcnNlUmF3RGF0ZVN0cmluZyh5ZWFyTW9udGhEYXlTdHJpbmcsICdZTUQnKTtcblxuICAgICAgICBpZiAoIVR1aVllYXIuaXNWYWxpZFllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUdWlJbnZhbGlkWWVhckV4Y2VwdGlvbih5ZWFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR1aUludmFsaWRNb250aEV4Y2VwdGlvbihtb250aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihkYXkpIHx8XG4gICAgICAgICAgICAhdHVpSW5SYW5nZShcbiAgICAgICAgICAgICAgICBkYXksXG4gICAgICAgICAgICAgICAgTUlOX0RBWSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aCwgVHVpWWVhci5pc0xlYXBZZWFyKHllYXIpKSArIDEsXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR1aUludmFsaWREYXlFeGNlcHRpb24oZGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgbm9ybWFsaXplRGF5UGFydChkYXk6IG51bWJlciwgbW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIHR1aUFzc2VydC5hc3NlcnQoVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSk7XG5cbiAgICAgICAgY29uc3QgbW9udGhEYXlzQ291bnQgPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChcbiAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgVHVpWWVhci5pc0xlYXBZZWFyKHllYXIpLFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0dWlOb3JtYWxpemVUb0ludE51bWJlcihkYXksIDEsIG1vbnRoRGF5c0NvdW50KTtcbiAgICB9XG5cbiAgICBnZXQgZm9ybWF0dGVkRGF5UGFydCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuZGF5KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH1cblxuICAgIGdldCBpc1dlZWtlbmQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGRheU9mV2VlayA9IHRoaXMuZGF5T2ZXZWVrKGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZGF5T2ZXZWVrID09PSBUdWlEYXlPZldlZWsuU2F0dXJkYXkgfHwgZGF5T2ZXZWVrID09PSBUdWlEYXlPZldlZWsuU3VuZGF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF5IG9mIHdlZWtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydEZyb21Nb25kYXkgd2hldGhlciB3ZWVrIHN0YXJ0cyBmcm9tIE1vbmRheSBhbmQgbm90IGZyb20gU3VuZGF5XG4gICAgICogQHJldHVybiBkYXkgb2Ygd2VlayAoZnJvbSAwIHRvIDYpXG4gICAgICovXG4gICAgZGF5T2ZXZWVrKHN0YXJ0RnJvbU1vbmRheTogYm9vbGVhbiA9IHRydWUpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkYXlPZldlZWsgPSBzdGFydEZyb21Nb25kYXlcbiAgICAgICAgICAgID8gdGhpcy50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldERheSgpIC0gMVxuICAgICAgICAgICAgOiB0aGlzLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0RGF5KCk7XG5cbiAgICAgICAgcmV0dXJuIGRheU9mV2VlayA8IDAgPyA2IDogZGF5T2ZXZWVrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGFmdGVyIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlCZWZvcmUoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQmVmb3JlKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPCBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBhZnRlciBvciBlcXVhbHMgdG8gY3VycmVudFxuICAgICAqL1xuICAgIGRheVNhbWVPckJlZm9yZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA8PSBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgZGF5U2FtZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID09PSBhbm90aGVyLmRheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBlaXRoZXIgYmVmb3JlIG9yIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlTYW1lT3JBZnRlcihhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhBZnRlcihhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID49IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGJlZm9yZSBjdXJyZW50XG4gICAgICovXG4gICAgZGF5QWZ0ZXIoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQWZ0ZXIoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA+IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1waW5nIGRhdGUgYmV0d2VlbiB0d28gbGltaXRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluXG4gICAgICogQHBhcmFtIG1heFxuICAgICAqIEByZXR1cm4gY2xhbXBlZCBkYXRlXG4gICAgICovXG4gICAgZGF5TGltaXQobWluOiBUdWlEYXkgfCBudWxsLCBtYXg6IFR1aURheSB8IG51bGwpOiBUdWlEYXkge1xuICAgICAgICBpZiAobWluICE9PSBudWxsICYmIHRoaXMuZGF5QmVmb3JlKG1pbikpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICE9PSBudWxsICYmIHRoaXMuZGF5QWZ0ZXIobWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltbXV0YWJseSBhbHRlcnMgY3VycmVudCBkYXkgYnkgcGFzc2VkIG9mZnNldFxuICAgICAqXG4gICAgICogSWYgcmVzdWx0aW5nIG1vbnRoIGhhcyBtb3JlIGRheXMgdGhhbiBvcmlnaW5hbCBvbmUsIGRhdGUgaXMgcm91bmRlZCB0byB0aGUgbWF4aW11bSBkYXlcbiAgICAgKiBpbiB0aGUgcmVzdWx0aW5nIG1vbnRoLiBPZmZzZXQgb2YgZGF5cyB3aWxsIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHJlc3VsdGVkIHllYXIgYW5kIG1vbnRoXG4gICAgICogdG8gbm90IGludGVyZmVyZSB3aXRoIHBhcmVudCBjbGFzc2VzIG1ldGhvZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIG5ldyBkYXRlIG9iamVjdCBhcyBhIHJlc3VsdCBvZiBvZmZzZXR0aW5nIGN1cnJlbnRcbiAgICAgKi9cbiAgICBvdmVycmlkZSBhcHBlbmQoe3llYXIgPSAwLCBtb250aCA9IDAsIGRheSA9IDB9OiBUdWlEYXlMaWtlKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3QgdG90YWxNb250aHMgPSAodGhpcy55ZWFyICsgeWVhcikgKiBNT05USFNfSU5fWUVBUiArIHRoaXMubW9udGggKyBtb250aDtcbiAgICAgICAgbGV0IHllYXJzID0gTWF0aC5mbG9vcih0b3RhbE1vbnRocyAvIE1PTlRIU19JTl9ZRUFSKTtcbiAgICAgICAgbGV0IG1vbnRocyA9IHRvdGFsTW9udGhzICUgTU9OVEhTX0lOX1lFQVI7XG5cbiAgICAgICAgbGV0IGRheXMgPVxuICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgdGhpcy5kYXksXG4gICAgICAgICAgICAgICAgVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKSxcbiAgICAgICAgICAgICkgKyBkYXk7XG5cbiAgICAgICAgd2hpbGUgKGRheXMgPiBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpKSB7XG4gICAgICAgICAgICBkYXlzIC09IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSk7XG5cbiAgICAgICAgICAgIGlmIChtb250aHMgPT09IFR1aU1vbnRoTnVtYmVyLkRlY2VtYmVyKSB7XG4gICAgICAgICAgICAgICAgeWVhcnMrKztcbiAgICAgICAgICAgICAgICBtb250aHMgPSBUdWlNb250aE51bWJlci5KYW51YXJ5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb250aHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChkYXlzIDwgTUlOX0RBWSkge1xuICAgICAgICAgICAgaWYgKG1vbnRocyA9PT0gVHVpTW9udGhOdW1iZXIuSmFudWFyeSkge1xuICAgICAgICAgICAgICAgIHllYXJzLS07XG4gICAgICAgICAgICAgICAgbW9udGhzID0gVHVpTW9udGhOdW1iZXIuRGVjZW1iZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRocy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXlzICs9IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheSh5ZWFycywgbW9udGhzLCBkYXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvcm1hdHRlZCB3aG9sZSBkYXRlXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQ6IFR1aURhdGVNb2RlLCBzZXBhcmF0b3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGVuZ3RoID09PSAxLFxuICAgICAgICAgICAgICAgICdTZXBhcmF0b3Igc2hvdWxkIGNvbnNpc3Qgb2Ygb25seSAxIHN5bWJvbCcsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGRkID0gdGhpcy5mb3JtYXR0ZWREYXlQYXJ0O1xuICAgICAgICBjb25zdCBtbSA9IHRoaXMuZm9ybWF0dGVkTW9udGhQYXJ0O1xuICAgICAgICBjb25zdCB5eXl5ID0gdGhpcy5mb3JtYXR0ZWRZZWFyO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0ZUZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAnWU1EJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7eXl5eX0ke3NlcGFyYXRvcn0ke21tfSR7c2VwYXJhdG9yfSR7ZGR9YDtcbiAgICAgICAgICAgIGNhc2UgJ01EWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke21tfSR7c2VwYXJhdG9yfSR7ZGR9JHtzZXBhcmF0b3J9JHt5eXl5fWA7XG4gICAgICAgICAgICBjYXNlICdETVknOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGR9JHtzZXBhcmF0b3J9JHttbX0ke3NlcGFyYXRvcn0ke3l5eXl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG92ZXJyaWRlIHRvU3RyaW5nKGRhdGVGb3JtYXQ6IFR1aURhdGVNb2RlID0gJ0RNWScsIHNlcGFyYXRvcjogc3RyaW5nID0gJy4nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci50b0pTT04oKX0tJHt0aGlzLmZvcm1hdHRlZERheVBhcnR9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgb3ZlcnJpZGUgdG9Mb2NhbE5hdGl2ZURhdGUoKTogRGF0ZSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5KTtcblxuICAgICAgICAvLyBuZWVkZWQgZm9yIHllYXJzIGxlc3MgdGhhbiAxOTAwXG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoTnVtYmVyKHRoaXMueWVhciA/PyAnMCcpKTtcblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gVVRDXG4gICAgICovXG4gICAgb3ZlcnJpZGUgdG9VdGNOYXRpdmVEYXRlKCk6IERhdGUge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEModGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSkpO1xuICAgIH1cbn1cbiJdfQ==