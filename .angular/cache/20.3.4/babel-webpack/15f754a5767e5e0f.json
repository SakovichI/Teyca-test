{"ast":null,"code":"import { tuiAssert, tuiIsSafari, CHAR_HYPHEN, tuiIsNativeFocused, tuiGetDocumentOrShadowRoot, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';\nimport { MASK_CARET_TRAP, TUI_DIGIT_REGEXP, TUI_NON_DIGITS_REGEXP, TUI_LEADING_ZEROES_REGEXP, TUI_DECIMAL_SYMBOLS } from '@taiga-ui/core/constants';\nimport { tuiOtherDecimalSymbol } from '@taiga-ui/core/utils/format';\nfunction addDecimalSymbolIfNeeded(value, decimalSymbol = ',') {\n  return !value.includes(decimalSymbol) ? value + decimalSymbol : value;\n}\nfunction calculateSafariCaret(previousValue = '', current, previousCaret, decimalSymbol = ',') {\n  const tailRegex = new RegExp(`${decimalSymbol}.+`);\n  const previousWithoutTail = previousValue.replace(tailRegex, '');\n  const currentWithoutTail = current.replace(tailRegex, '');\n  const pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;\n  if (pasteOrCutOperation) {\n    return current.length;\n  }\n  if (previousValue.length === current.length) {\n    if (previousValue.indexOf(decimalSymbol) <= previousCaret) {\n      return calculateChangedTailIndex(previousValue, current);\n    }\n    return previousWithoutTail === currentWithoutTail ? previousCaret - 1 : previousCaret + 1;\n  }\n  if (previousValue.length === 0) {\n    return 1;\n  }\n  const changeLength = current.length - previousValue.length;\n  return previousCaret + changeLength;\n}\nfunction calculateChangedTailIndex(previous, current) {\n  for (let i = 0; i < current.length; i++) {\n    if (previous[i] !== current[i]) {\n      return current[i] === '0' ? i : i + 1;\n    }\n  }\n  return current.length;\n}\nfunction calculateCaretGap(previousValue = '', current, thousandSymbol) {\n  const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;\n  if (pasteOrCutOperation) {\n    return 0;\n  }\n  const wereSpaces = previousValue.split(thousandSymbol).length;\n  const nowSpaces = current.split(thousandSymbol).length;\n  return nowSpaces - wereSpaces;\n}\n/**\n * TODO: delete in v4.0\n * @deprecated Use {@link https://maskito.dev/kit/number Number} from {@link https://github.com/taiga-family/maskito Maskito} instead <br/>\n * Used to finish a number with zeros to a given precision\n */\nfunction tuiCreateAutoCorrectedNumberPipe(decimalLimit = 0, decimalSymbol = ',', thousandSymbol = CHAR_NO_BREAK_SPACE, nativeInput, allowNegative, isIOS = false) {\n  ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n  // Guess for which browser I need this :)\n  let previousCaret = -1;\n  const unlucky = !!nativeInput && tuiIsSafari(nativeInput) || isIOS;\n  if (nativeInput && unlucky) {\n    nativeInput.addEventListener('beforeinput', () => {\n      previousCaret = nativeInput.selectionStart || 0;\n    });\n  }\n  return (conformedValue, config) => {\n    // Removing everything by selecting and pressing '-'\n    if (!conformedValue && config.rawValue === CHAR_HYPHEN && allowNegative) {\n      return CHAR_HYPHEN;\n    }\n    // remove these hacks after text mask library has changed\n    if (nativeInput && unlucky && tuiIsNativeFocused(nativeInput)) {\n      const caret = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);\n      setTimeout(() => {\n        nativeInput.setSelectionRange(caret, caret);\n      });\n    }\n    if (nativeInput && nativeInput.ownerDocument !== tuiGetDocumentOrShadowRoot(nativeInput) && tuiIsNativeFocused(nativeInput) && config.currentCaretPosition) {\n      const realCaretPosition = config.currentCaretPosition + calculateCaretGap(config.previousConformedValue, conformedValue, thousandSymbol);\n      setTimeout(() => {\n        nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);\n      });\n    }\n    if (conformedValue === '' || !decimalLimit || !Number.isInteger(decimalLimit)) {\n      return {\n        value: conformedValue\n      };\n    }\n    const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);\n    const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];\n    const zeroPaddingSize = decimalLimit - decimalPart.length;\n    return {\n      value: withDecimalSymbol + '0'.repeat(zeroPaddingSize)\n    };\n  };\n}\nconst ASSERTION = 'Correction function must return single char or null';\n/**\n * TODO: delete in v4.0\n * @deprecated Use {@link https://maskito.dev/core-concepts/processors processors} from {@link https://github.com/taiga-family/maskito Maskito}\n */\nfunction tuiCreateCorrectionMask(allowed, correctionHandler) {\n  return rawValue => {\n    const mask = rawValue.split('').reduce((result, char, index) => {\n      const corrected = correctionHandler(char, index);\n      ngDevMode && tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);\n      if (!allowed.test(char) && !corrected) {\n        return result;\n      }\n      if (allowed.test(char)) {\n        return [...result, allowed];\n      }\n      if (corrected) {\n        return [...result, corrected, MASK_CARET_TRAP];\n      }\n      return result;\n    }, []);\n    const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);\n    const filtered = mask.filter((item, index) => item !== MASK_CARET_TRAP || index === lastIndex);\n    return filtered.some(item => item !== allowed) ? [...filtered, allowed] : filtered;\n  };\n}\nconst NON_ZERO_DIGIT = /[1-9]/;\nfunction preventLeadingZeroes(mask, isOnlyZeroDigit = false, leadingZerosAmount = 0) {\n  if (isOnlyZeroDigit || leadingZerosAmount === 0) {\n    return mask;\n  }\n  const firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);\n  if (firstDigitIndex === -1) {\n    return mask;\n  }\n  const secondMaskDigit = mask[firstDigitIndex + 1];\n  const isCaretTrap = secondMaskDigit === MASK_CARET_TRAP;\n  if (isCaretTrap && leadingZerosAmount === 1) {\n    return mask;\n  }\n  if (isCaretTrap) {\n    mask.unshift(NON_ZERO_DIGIT);\n    return mask;\n  }\n  mask[firstDigitIndex] = NON_ZERO_DIGIT;\n  return mask;\n}\nfunction getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {\n  if (!autoCorrectDecimalSymbol) {\n    return str.lastIndexOf(decimalSymbol);\n  }\n  return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(tuiOtherDecimalSymbol(decimalSymbol)));\n}\nfunction isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {\n  if (autoCorrectDecimalSymbol) {\n    return /^[,.]$/.test(str);\n  }\n  return str === decimalSymbol;\n}\nfunction convertToMask(strNumber) {\n  return strNumber.split('').map(char => TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char);\n}\nfunction addThousandsSeparator(strNumber, thousandSymbol) {\n  return strNumber.length > 3 ?\n  // TODO: investigate to disallow potentially catastrophic exponential-time regular expressions.\n  // eslint-disable-next-line unicorn/no-unsafe-regex\n  strNumber.replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandSymbol) : strNumber;\n}\n/**\n * TODO: delete in v4.0\n * @deprecated Use {@link https://maskito.dev/kit/number Number} from {@link https://github.com/taiga-family/maskito Maskito} instead <br/>\n * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}\n */\nfunction tuiCreateNumberMask({\n  allowDecimal = false,\n  decimalSymbol = ',',\n  thousandSymbol = CHAR_NO_BREAK_SPACE,\n  autoCorrectDecimalSymbol = true,\n  decimalLimit = 2,\n  requireDecimal = false,\n  allowNegative = false,\n  integerLimit = 0\n} = {}) {\n  ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n  ngDevMode && tuiAssert.assert(Number.isInteger(integerLimit));\n  ngDevMode && tuiAssert.assert(integerLimit >= 0);\n  return (rawValue, {\n    previousConformedValue\n  }) => {\n    if (previousConformedValue && requireDecimal) {\n      const conformedWithoutSeparator = rawValue.split(thousandSymbol).join('');\n      const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue.split(thousandSymbol).join('').split(decimalSymbol).join('');\n      // Forbid removal of decimal separator if decimal part is required\n      if (conformedWithoutSeparator === previousConformedValueWithoutDecimalSymbolAndSeparator) {\n        rawValue = previousConformedValue;\n      }\n    }\n    const isNegative = ((rawValue === null || rawValue === void 0 ? void 0 : rawValue.startsWith(CHAR_HYPHEN)) || (rawValue === null || rawValue === void 0 ? void 0 : rawValue.startsWith(CHAR_EN_DASH))) && allowNegative;\n    if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) && allowDecimal) {\n      return ['0', decimalSymbol, TUI_DIGIT_REGEXP];\n    }\n    if (isNegative) {\n      rawValue = rawValue.slice(1);\n    }\n    const decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);\n    const hasDecimal = decimalIndex !== -1;\n    const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;\n    const thousandSeparators = integer.match(new RegExp(thousandSymbol, 'g')) || [];\n    const integerCapped = integerLimit ? integer.slice(0, integerLimit + thousandSeparators.length) : integer;\n    const integerCappedClean = integerCapped.replace(TUI_NON_DIGITS_REGEXP, '');\n    const [leadingZerosMatch] = integerCappedClean.match(TUI_LEADING_ZEROES_REGEXP) || [''];\n    const leadingZerosAmount = leadingZerosMatch.length;\n    const integerCappedZerosClean = integerCappedClean.replace(/^0+(?!\\.|$)/, '').trim();\n    const withSeparator = addThousandsSeparator(integerCappedZerosClean, thousandSymbol);\n    const mask = convertToMask(withSeparator);\n    if (hasDecimal && allowDecimal || requireDecimal) {\n      const fraction = hasDecimal ? convertToMask(rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, '')) : [];\n      const fractionCapped = decimalLimit ? fraction.slice(0, decimalLimit) : fraction;\n      if (rawValue[decimalIndex] !== tuiOtherDecimalSymbol(decimalSymbol)) {\n        mask.push(MASK_CARET_TRAP);\n      }\n      mask.push(decimalSymbol, MASK_CARET_TRAP, ...fractionCapped);\n      for (let i = 0; i < Math.min(decimalLimit - fractionCapped.length, 20); i++) {\n        mask.push(TUI_DIGIT_REGEXP);\n      }\n    }\n    const isOnlyZeroDigit = mask.length === 1 && integerCappedZerosClean === '0';\n    if (isNegative) {\n      if (mask.length === 0) {\n        mask.push(TUI_DIGIT_REGEXP);\n      }\n      mask.unshift(CHAR_HYPHEN);\n    }\n    return preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount);\n  };\n}\n\n/**\n * TODO: delete in v4.0\n * @deprecated Use {@link https://maskito.dev/kit/number Number} from {@link https://github.com/taiga-family/maskito Maskito} instead\n */\nfunction tuiEnableAutoCorrectDecimalSymbol({\n  thousandSeparator\n}) {\n  return !TUI_DECIMAL_SYMBOLS.includes(thousandSeparator);\n}\n\n/**\n * TODO: delete in v4.0\n * @deprecated use {@link https://maskito.dev/kit/number maskitoParseNumber} instead\n * ```ts\n * Number.isNaN(maskitoParseNumber(value, decimalSeparator))\n * ```\n */\nfunction tuiMaskedMoneyValueIsEmpty(value) {\n  switch (value) {\n    case '':\n    case CHAR_HYPHEN:\n    case ',':\n    case `${CHAR_HYPHEN},`:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * TODO: delete in v4.0\n * @deprecated use {@link https://maskito.dev/kit/number maskitoParseNumber} instead\n */\nfunction tuiMaskedNumberStringToNumber(value, decimalsSymbol, thousandSymbol) {\n  return parseFloat(value.split(thousandSymbol).join('').split(decimalsSymbol).join('.'));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCreateAutoCorrectedNumberPipe, tuiCreateCorrectionMask, tuiCreateNumberMask, tuiEnableAutoCorrectDecimalSymbol, tuiMaskedMoneyValueIsEmpty, tuiMaskedNumberStringToNumber };\n//# sourceMappingURL=taiga-ui-core-utils-mask.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}