{"ast":null,"code":"function tuiHexToRgb(hex) {\n  const matches = hex.replace('#', '').split('').map((char, _, array) => array.length === 3 ? char + char : char).join('').match(/.{2}/g);\n  return matches ? matches.map(x => Number.parseInt(x, 16)) : [0, 0, 0];\n}\nconst getChunksFromString = (hex, chunkSize) => hex.match(new RegExp(`.{${chunkSize}}`, 'g'));\nconst convertHexUnitTo256 = hexStr => parseInt(hexStr.repeat(2 / hexStr.length), 16);\nconst getAlphaFloat = (a, alpha) => {\n  if (typeof a !== 'undefined') {\n    return Number((a / 255).toFixed(2));\n  }\n  if (typeof alpha !== 'number' || alpha < 0 || alpha > 1) {\n    return 1;\n  }\n  return alpha;\n};\nfunction tuiHexToRGBA(hex, alpha) {\n  const [r, g, b, a] = tuiParseHex(hex, alpha);\n  return a < 1 ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`;\n}\nfunction tuiIsValidHex(hex) {\n  // eslint-disable-next-line unicorn/no-unsafe-regex\n  return /^#([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);\n}\nfunction tuiParseHex(hex, alpha) {\n  var _a;\n  if (!tuiIsValidHex(hex)) {\n    throw new Error('Invalid HEX');\n  }\n  const chunkSize = Math.floor((hex.length - 1) / 3);\n  const hexArr = getChunksFromString(hex.slice(1), chunkSize);\n  const [r, g, b, a] = (_a = hexArr === null || hexArr === void 0 ? void 0 : hexArr.map(convertHexUnitTo256)) !== null && _a !== void 0 ? _a : [];\n  const floatAlpha = getAlphaFloat(a, alpha);\n  return [r, g, b, floatAlpha];\n}\nfunction hsvToColor(h, s, v, n) {\n  const k = (n + h / 60) % 6;\n  return Math.round(v - v * s * Math.max(Math.min(k, 4 - k, 1), 0));\n}\n/**\n * https://stackoverflow.com/a/54024653/2706426\n */\nfunction tuiHsvToRgb(h, s, v) {\n  return [hsvToColor(h, s, v, 5), hsvToColor(h, s, v, 3), hsvToColor(h, s, v, 1)];\n}\nconst DEFAULT = [0, 0, 0, 1];\nfunction tuiParseColor(color) {\n  const stripped = color.replace('#', '').replace('rgba(', '').replace('rgb(', '').replace(')', '');\n  const array = stripped.split(',').map(item => parseFloat(item));\n  if (array.length === 4) {\n    return array;\n  }\n  if (array.length === 3) {\n    return array.concat(1);\n  }\n  const matches = stripped.match(new RegExp(`(.{${stripped.length / 3}})`, 'g'));\n  if (!matches) {\n    return DEFAULT;\n  }\n  const parsed = matches.map(char => parseInt(stripped.length % 2 ? char + char : char, 16));\n  return [parsed[0] || DEFAULT[0], parsed[1] || DEFAULT[1], parsed[2] || DEFAULT[2], parsed[3] === undefined ? DEFAULT[3] : parsed[3]];\n}\nfunction tuiRgbToHex(r, g, b) {\n  return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;\n}\nfunction tuiRgbToHsv(r, g, b) {\n  const v = Math.max(r, g, b);\n  const n = v - Math.min(r, g, b);\n  // eslint-disable-next-line no-nested-ternary\n  const h = n && (v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n);\n  return [60 * (h < 0 ? h + 6 : h), v && n / v, v];\n}\nfunction tuiRgbaToHex(color) {\n  var _a, _b;\n  if (!tuiIsValidRgba(color)) {\n    throw new Error('Invalid RGBa');\n  }\n  const rgb = (_a = color.replace(/\\s/g, '')\n  // eslint-disable-next-line unicorn/no-unsafe-regex\n  .match(/^rgba?\\((\\d+),(\\d+),(\\d+),?([^,\\s)]+)?/i)) !== null && _a !== void 0 ? _a : [];\n  let alpha = ((_b = rgb === null || rgb === void 0 ? void 0 : rgb[4]) !== null && _b !== void 0 ? _b : '').toString().trim();\n  let hex = rgb ? (rgb[1] | 1 << 8).toString(16).slice(1) + (rgb[2] | 1 << 8).toString(16).slice(1) + (rgb[3] | 1 << 8).toString(16).slice(1) : color;\n  alpha = alpha !== '' ? alpha : 0o1;\n  alpha = (Number(alpha) * 255 | 1 << 8).toString(16).slice(1);\n  hex += alpha;\n  return `#${hex.toUpperCase()}`;\n}\nfunction tuiIsValidRgba(rgba) {\n  const range = '(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4]\\\\d|2[0-5]{2})';\n  const alpha = '([01]|0?\\\\.\\\\d+)';\n  return new RegExp(`^(?:rgb\\\\(\\\\s*${range}\\\\s*,\\\\s*${range}\\\\s*,\\\\s*${range}\\\\s*\\\\)|rgba\\\\(\\\\s*${range}\\\\s*,\\\\s*${range}\\\\s*,\\\\s*${range}\\\\s*,\\\\s*${alpha}\\\\s*\\\\))$`).test(rgba);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiHexToRGBA, tuiHexToRgb, tuiHsvToRgb, tuiIsValidHex, tuiIsValidRgba, tuiParseColor, tuiParseHex, tuiRgbToHex, tuiRgbToHsv, tuiRgbaToHex };\n//# sourceMappingURL=taiga-ui-cdk-utils-color.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}