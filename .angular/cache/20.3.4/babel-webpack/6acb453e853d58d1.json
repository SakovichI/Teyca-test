{"ast":null,"code":"import { Injector, inject, signal } from '@angular/core';\nimport { toObservable, toSignal } from '@angular/core/rxjs-interop';\nimport { Subject, catchError, debounceTime, filter, finalize, map, of, startWith, switchMap, take, tap } from 'rxjs';\nimport { DEBOUNCE_TIME_UI } from '../../constants';\nimport { negativeBoolean, combineLatestIntoObject, toResult } from '../../helpers';\nexport class ListDataSource {\n  #defaultPageIndex = 0;\n  #optionsSubject = new Subject();\n  #dataSignal = signal([], ...(ngDevMode ? [{\n    debugName: \"#dataSignal\"\n  }] : []));\n  #pageIndexSignal = signal(this.#defaultPageIndex, ...(ngDevMode ? [{\n    debugName: \"#pageIndexSignal\"\n  }] : []));\n  #pagesLengthSignal = signal(0, ...(ngDevMode ? [{\n    debugName: \"#pagesLengthSignal\"\n  }] : []));\n  #isLoadingSignal = signal(true, ...(ngDevMode ? [{\n    debugName: \"#isLoadingSignal\"\n  }] : []));\n  #isEmptyDataSignal = signal(true, ...(ngDevMode ? [{\n    debugName: \"#isEmptyDataSignal\"\n  }] : []));\n  #refreshSubject = new Subject();\n  #injector = inject(Injector);\n  limit = 10;\n  $data = this.#initData();\n  $isLoading = this.#isLoadingSignal.asReadonly();\n  $isEmptyData = this.#isEmptyDataSignal.asReadonly();\n  $pageIndex = this.#pageIndexSignal.asReadonly();\n  $pagesLength = this.#pagesLengthSignal.asReadonly();\n  get data() {\n    return this.#dataSignal();\n  }\n  get length() {\n    return this.data.length;\n  }\n  get isLoading() {\n    return this.#isLoadingSignal();\n  }\n  initDataSource(options) {\n    this.#optionsSubject.next(options);\n  }\n  refresh() {\n    this.#refreshSubject.next();\n    const toEmptyValue = () => undefined;\n    return toObservable(this.#isLoadingSignal, {\n      injector: this.#injector\n    }).pipe(filter(negativeBoolean), take(1), map(toEmptyValue));\n  }\n  resetData() {\n    this.#isEmptyDataSignal.set(true);\n  }\n  #initData() {\n    const toParamsWithRefresh = params => {\n      return this.#mergeParamsWithRefresh(params);\n    };\n    const toDataFlow = params => {\n      return this.#createDataFlow(params);\n    };\n    const toDataStream = options => {\n      return this.#createParamsObservable(options).pipe(switchMap(toParamsWithRefresh), switchMap(toDataFlow));\n    };\n    return toSignal(this.#optionsSubject.pipe(switchMap(toDataStream)), {\n      initialValue: []\n    });\n  }\n  #createParamsObservable({\n    tableComponent,\n    form\n  }) {\n    const pagination = tableComponent.$pagination();\n    return combineLatestIntoObject({\n      pagination: this.#createPaginationObservable(pagination),\n      orderBy: this.#createOrderByObservable(tableComponent?.$sort(), pagination),\n      filterValues: this.#createFilterObservable(form, pagination),\n      directionOrder: this.#createDirectionObservable(tableComponent?.$table()?.direction, tableComponent?.$direction(), pagination)\n    }).pipe(debounceTime(DEBOUNCE_TIME_UI));\n  }\n  #mergeParamsWithRefresh(params) {\n    const toParams = () => params;\n    return this.#refreshSubject.pipe(map(toParams), startWith(params));\n  }\n  #createPaginationObservable(pagination) {\n    if (!pagination) return of({\n      limit: this.limit,\n      offset: 0\n    });\n    const setPageIndex = offset => this.#pageIndexSignal.set(offset);\n    const toPagination = offset => ({\n      offset: offset * this.limit,\n      limit: this.limit\n    });\n    return pagination.indexChange.pipe(startWith(pagination.index), tap(setPageIndex), map(toPagination));\n  }\n  #createOrderByObservable(sort, pagination) {\n    if (!sort) return of(null);\n    return sort.tuiSortByChange.pipe(tap(this.#resetPage(pagination)), startWith(sort.tuiSortBy));\n  }\n  #createDirectionObservable(initialDirection, direction, pagination) {\n    if (!direction) return of(null);\n    const currentDirectionOrder = initialDirection === 1 ? 'asc' : 'desc';\n    return direction.directionOrderChange.pipe(tap(this.#resetPage(pagination)), startWith(currentDirectionOrder));\n  }\n  #createFilterObservable(form, pagination) {\n    if (!form) return of(null);\n    return form.valueChanges.pipe(tap(this.#resetPage(pagination)), startWith(form.value));\n  }\n  #createDataFlow(params) {\n    const setIsLoading = isLoading => () => this.#isLoadingSignal.set(isLoading);\n    const setIsEmptyData = () => this.#isEmptyDataSignal.set(!this.length);\n    const setPagesLength = ({\n      meta\n    }) => {\n      const pagesLength = Math.ceil(meta.size / this.limit);\n      this.#pagesLengthSignal.set(pagesLength);\n    };\n    const toData = () => this.getApiData(params);\n    const setData = data => this.#dataSignal.set(data);\n    const handleError = error => {\n      console.error(error);\n      return of(null);\n    };\n    return of(null).pipe(tap(setIsLoading(true)), switchMap(toData), tap(setPagesLength), map(toResult), tap(setData), catchError(handleError), filter(Boolean), finalize(setIsEmptyData), finalize(setIsLoading(false)));\n  }\n  #resetPage = pagination => () => {\n    if (!pagination) return;\n    pagination.onElementClick(this.#defaultPageIndex);\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}