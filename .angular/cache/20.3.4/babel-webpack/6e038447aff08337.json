{"ast":null,"code":"import { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { ElementRef, Renderer2, Directive, Inject, HostListener, NgModule } from '@angular/core';\nimport { tuiContainsOrAfter, tuiIsHTMLElement } from '@taiga-ui/cdk/utils/dom';\nimport { tuiGetNativeFocused, tuiGetClosestFocusable, tuiBlurNativeFocused } from '@taiga-ui/cdk/utils/focus';\nlet TuiFocusTrapDirective = /*#__PURE__*/(() => {\n  class TuiFocusTrapDirective {\n    constructor(doc, el, renderer) {\n      this.doc = doc;\n      this.el = el;\n      this.renderer = renderer;\n      this.activeElement = tuiGetNativeFocused(this.doc);\n      /**\n       * This would cause currently focused element to lose focus,\n       * but it might cause ExpressionChanged error due to potential HostBinding.\n       * Microtask keeps it in the same frame but allows change detection to run\n       */\n      void Promise.resolve().then(() => this.el.nativeElement.focus());\n    }\n    onBlur() {\n      this.renderer.removeAttribute(this.el.nativeElement, 'tabIndex');\n    }\n    onFocusIn(node) {\n      const {\n        nativeElement\n      } = this.el;\n      if (tuiContainsOrAfter(nativeElement, node)) {\n        return;\n      }\n      const focusable = tuiGetClosestFocusable({\n        initial: nativeElement,\n        root: nativeElement\n      });\n      if (focusable) {\n        focusable.focus();\n      }\n    }\n    ngOnDestroy() {\n      tuiBlurNativeFocused(this.doc);\n      /**\n       * HostListeners are triggered even after ngOnDestroy\n       * {@link https://github.com/angular/angular/issues/38100}\n       * so we need to delay it but stay in the same sync cycle,\n       * therefore using Promise instead of setTimeout\n       */\n      // eslint-disable-next-line\n      Promise.resolve().then(() => {\n        if (tuiIsHTMLElement(this.activeElement)) {\n          this.activeElement.focus();\n        }\n      });\n    }\n  }\n  TuiFocusTrapDirective.ɵfac = function TuiFocusTrapDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiFocusTrapDirective)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(Renderer2));\n  };\n  TuiFocusTrapDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiFocusTrapDirective,\n    selectors: [[\"\", \"tuiFocusTrap\", \"\"]],\n    hostAttrs: [\"tabIndex\", \"0\"],\n    hostBindings: function TuiFocusTrapDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"blur\", function TuiFocusTrapDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"focusin.silent\", function TuiFocusTrapDirective_focusin_silent_HostBindingHandler($event) {\n          return ctx.onFocusIn($event.target);\n        }, i0.ɵɵresolveWindow);\n      }\n    },\n    standalone: false\n  });\n  return TuiFocusTrapDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiFocusTrapModule = /*#__PURE__*/(() => {\n  class TuiFocusTrapModule {}\n  TuiFocusTrapModule.ɵfac = function TuiFocusTrapModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiFocusTrapModule)();\n  };\n  TuiFocusTrapModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TuiFocusTrapModule\n  });\n  TuiFocusTrapModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TuiFocusTrapModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiFocusTrapDirective, TuiFocusTrapModule };\n//# sourceMappingURL=taiga-ui-cdk-directives-focus-trap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}