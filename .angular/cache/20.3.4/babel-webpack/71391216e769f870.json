{"ast":null,"code":"import { tuiIsHTMLElement } from '@taiga-ui/cdk/utils/dom';\nimport { svgNodeFilter } from '@taiga-ui/cdk/constants';\n\n/**\n * Returns current active element, including shadow dom\n *\n * @return element or null\n */\nfunction tuiGetNativeFocused({\n  activeElement\n}) {\n  if (!(activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot)) {\n    return activeElement;\n  }\n  let element = activeElement.shadowRoot.activeElement;\n  while (element === null || element === void 0 ? void 0 : element.shadowRoot) {\n    element = element.shadowRoot.activeElement;\n  }\n  return element;\n}\n\n/**\n * Finds and blurs current active element, including shadow DOM\n */\nfunction tuiBlurNativeFocused(doc) {\n  const activeElement = tuiGetNativeFocused(doc);\n  if (tuiIsHTMLElement(activeElement)) {\n    activeElement.blur();\n  }\n}\n\n/**\n * Checks for signs that element can be focused with keyboard. tabIndex above 0 is ignored to\n * only target natural focus order. Not checking the possibility of an element to\n * be focused, for example element can have display: none applied to it or any other\n * circumstances could prevent actual focus.\n */\nfunction tuiIsNativeKeyboardFocusable(element) {\n  if (element.hasAttribute('disabled') || element.getAttribute('tabIndex') === '-1') {\n    return false;\n  }\n  if (tuiIsHTMLElement(element) && element.isContentEditable || element.getAttribute('tabIndex') === '0') {\n    return true;\n  }\n  switch (element.tagName) {\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA':\n      return true;\n    case 'VIDEO':\n    case 'AUDIO':\n      return element.hasAttribute('controls');\n    case 'INPUT':\n      return element.getAttribute('type') !== 'hidden';\n    case 'A':\n    case 'LINK':\n      return element.hasAttribute('href');\n    default:\n      return false;\n  }\n}\nfunction tuiIsNativeMouseFocusable(element) {\n  return !element.hasAttribute('disabled') && (element.getAttribute('tabIndex') === '-1' || tuiIsNativeKeyboardFocusable(element));\n}\n\n/**\n * @description:\n * Finds the closest element that can be focused with a keyboard or mouse in theory\n */\nfunction tuiGetClosestFocusable({\n  initial,\n  root,\n  previous = false,\n  keyboard = true\n}) {\n  if (!root.ownerDocument) {\n    return null;\n  }\n  const check = keyboard ? tuiIsNativeKeyboardFocusable : tuiIsNativeMouseFocusable;\n  const treeWalker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, svgNodeFilter);\n  treeWalker.currentNode = initial;\n  while (previous ? treeWalker.previousNode() : treeWalker.nextNode()) {\n    if (tuiIsHTMLElement(treeWalker.currentNode)) {\n      initial = treeWalker.currentNode;\n    }\n    if (tuiIsHTMLElement(initial) && check(initial)) {\n      return initial;\n    }\n  }\n  return null;\n}\n\n/**\n * Checks if element is focused.\n *\n * Could return true even after blur since element remains focused if you switch away from a browser tab.\n *\n * @param node or null (as a common return value of DOM nodes walking)\n * @return true if focused\n */\nfunction tuiIsNativeFocused(node) {\n  return !!(node === null || node === void 0 ? void 0 : node.ownerDocument) && tuiGetNativeFocused(node.ownerDocument) === node && node.ownerDocument.hasFocus();\n}\n\n/**\n * Checks if focused element is within given element.\n *\n * @param node\n * @return true if focused node is contained within element\n */\nfunction tuiIsNativeFocusedIn(node) {\n  // !node.contains - check for IE11\n  if (!node.ownerDocument || !node.contains) {\n    return false;\n  }\n  const nativeFocused = tuiGetNativeFocused(node.ownerDocument);\n  return nativeFocused !== null && node.contains(nativeFocused) && node.ownerDocument.hasFocus();\n}\n\n/**\n * Utility method for moving focus in a list of elements\n *\n * @param currentIndex currently focused index\n * @param elements array of focusable elements\n * @param step a step to move focus by, typically -1 or 1\n */\nfunction tuiMoveFocus(currentIndex, elements, step) {\n  currentIndex += step;\n  while (currentIndex >= 0 && currentIndex < elements.length) {\n    elements[currentIndex].focus();\n    if (tuiIsNativeFocused(elements[currentIndex])) {\n      return;\n    }\n    currentIndex += step;\n  }\n}\n\n/**\n * Focuses or blurs element with mouse action imitation (to spoof {@link TuiFocusVisibleService})\n *\n * @param element\n * @param focused desired focused state\n * @param preventScroll optionally prevent native browser scroll after focus\n */\nfunction tuiSetNativeMouseFocused(element, focused = true, preventScroll = false) {\n  if (!element.ownerDocument) {\n    return;\n  }\n  if (typeof Event === 'function') {\n    element.dispatchEvent(new MouseEvent('mousedown', {\n      bubbles: true,\n      cancelable: true\n    }));\n  } else {\n    const event = element.ownerDocument.createEvent('Event');\n    event.initEvent('mousedown', true, true);\n    element.dispatchEvent(event);\n  }\n  if (focused) {\n    element.focus({\n      preventScroll\n    });\n  } else {\n    element.blur();\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiBlurNativeFocused, tuiGetClosestFocusable, tuiGetNativeFocused, tuiIsNativeFocused, tuiIsNativeFocusedIn, tuiIsNativeKeyboardFocusable, tuiIsNativeMouseFocusable, tuiMoveFocus, tuiSetNativeMouseFocused };\n//# sourceMappingURL=taiga-ui-cdk-utils-focus.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}