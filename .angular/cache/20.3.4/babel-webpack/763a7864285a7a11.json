{"ast":null,"code":"import { MASKITO_DEFAULT_OPTIONS, maskitoTransform } from '@maskito/core';\nconst DEFAULT_DECIMAL_PSEUDO_SEPARATORS = ['.', ',', 'б', 'ю'];\nconst DEFAULT_MIN_DATE = new Date('0001-01-01');\nconst DEFAULT_MAX_DATE = new Date('9999-12-31');\nconst DEFAULT_TIME_SEGMENT_MAX_VALUES = {\n  hours: 23,\n  minutes: 59,\n  seconds: 59,\n  milliseconds: 999\n};\n\n/**\r\n * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.\r\n */\nconst CHAR_NO_BREAK_SPACE = '\\u00A0';\n/**\r\n * {@link https://unicode-table.com/en/2013/ EN dash}\r\n * is used to indicate a range of numbers or a span of time.\r\n * @example 2006–2022\r\n */\n\nconst CHAR_EN_DASH = '\\u2013';\n/**\r\n * {@link https://unicode-table.com/en/2014/ EM dash}\r\n * is used to mark a break in a sentence.\r\n * @example Taiga UI — powerful set of open source components for Angular\r\n * ___\r\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_HYPHEN}!\r\n */\n\nconst CHAR_EM_DASH = '\\u2014';\n/**\r\n * {@link https://unicode-table.com/en/002D/ Hyphen (minus sign)}\r\n * is used to combine words.\r\n * @example well-behaved\r\n * ___\r\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_EM_DASH}!\r\n */\n\nconst CHAR_HYPHEN = '\\u002D';\n/**\r\n * {@link https://unicode-table.com/en/2212/ Minus}\r\n * is used as math operator symbol or before negative digits.\r\n * ---\r\n * Can be used as `&minus;`. Don't confuse with {@link CHAR_HYPHEN}\r\n */\n\nconst CHAR_MINUS = '\\u2212';\nconst POSSIBLE_DATE_RANGE_SEPARATOR = [CHAR_HYPHEN, CHAR_EN_DASH, CHAR_EM_DASH, CHAR_MINUS];\nconst POSSIBLE_DATE_TIME_SEPARATOR = [',', ' '];\nconst TIME_FIXED_CHARACTERS = [':', '.'];\nconst TIME_SEGMENT_VALUE_LENGTHS = {\n  hours: 2,\n  minutes: 2,\n  seconds: 2,\n  milliseconds: 3\n};\n\n/**\r\n * Clamps a value between two inclusive limits\r\n *\r\n * @param value\r\n * @param min lower limit\r\n * @param max upper limit\r\n */\nfunction clamp(value, min, max) {\n  const clampedValue = Math.min(Number(max), Math.max(Number(min), Number(value)));\n  return value instanceof Date ? new Date(clampedValue) : clampedValue;\n}\nfunction appendDate(initialDate, {\n  day,\n  month,\n  year\n} = {}) {\n  const date = new Date(initialDate);\n  if (day) {\n    date.setDate(date.getDate() + day);\n  }\n  if (month) {\n    date.setMonth(date.getMonth() + month);\n  }\n  if (year) {\n    date.setFullYear(date.getFullYear() + year);\n  }\n  return date;\n}\nconst getDateSegmentValueLength = dateString => {\n  var _a, _b, _c;\n  return {\n    day: ((_a = dateString.match(/d/g)) === null || _a === void 0 ? void 0 : _a.length) || 0,\n    month: ((_b = dateString.match(/m/g)) === null || _b === void 0 ? void 0 : _b.length) || 0,\n    year: ((_c = dateString.match(/y/g)) === null || _c === void 0 ? void 0 : _c.length) || 0\n  };\n};\nfunction dateToSegments(date) {\n  return {\n    day: String(date.getDate()).padStart(2, '0'),\n    month: String(date.getMonth() + 1).padStart(2, '0'),\n    year: String(date.getFullYear()).padStart(4, '0'),\n    hours: String(date.getHours()).padStart(2, '0'),\n    minutes: String(date.getMinutes()).padStart(2, '0'),\n    seconds: String(date.getSeconds()).padStart(2, '0'),\n    milliseconds: String(date.getMilliseconds()).padStart(3, '0')\n  };\n}\nfunction isDateStringComplete(dateString, dateModeTemplate) {\n  if (dateString.length < dateModeTemplate.length) {\n    return false;\n  }\n  return dateString.split(/\\D/).every(segment => !segment.match(/^0+$/));\n}\nfunction parseDateRangeString(dateRange, dateModeTemplate, rangeSeparator) {\n  const digitsInDate = dateModeTemplate.replace(/\\W/g, '').length;\n  return dateRange.replace(rangeSeparator, '').match(new RegExp(`(\\\\D*\\\\d[^\\\\d\\\\s]*){1,${digitsInDate}}`, 'g')) || [];\n}\n\n/**\r\n * @deprecated use `Object.fromEntries` instead\r\n * (check browser support first https://caniuse.com/mdn-javascript_builtins_object_fromentries)\r\n * ___\r\n * TODO: after we bump Firefox to 63+ replace this function with `Object.fromEntries`.\r\n * TODO: Add `es2019.object` to `tsconfig.json` => `compilerOptions.lib`.\r\n *\r\n */\nfunction getObjectFromEntries(keyValuePairs) {\n  return keyValuePairs.reduce((obj, [key, val]) => Object.assign(Object.assign({}, obj), {\n    [key]: val\n  }), {});\n}\nfunction parseDateString(dateString, fullMode) {\n  const cleanMode = fullMode.replace(/[^dmy]/g, '');\n  const onlyDigitsDate = dateString.replace(/\\D+/g, '');\n  const dateSegments = {\n    day: onlyDigitsDate.slice(cleanMode.indexOf('d'), cleanMode.lastIndexOf('d') + 1),\n    month: onlyDigitsDate.slice(cleanMode.indexOf('m'), cleanMode.lastIndexOf('m') + 1),\n    year: onlyDigitsDate.slice(cleanMode.indexOf('y'), cleanMode.lastIndexOf('y') + 1)\n  };\n  return getObjectFromEntries(Object.entries(dateSegments).filter(([_, value]) => Boolean(value)).sort(([a], [b]) => fullMode.toLowerCase().indexOf(a[0]) > fullMode.toLowerCase().indexOf(b[0]) ? 1 : -1));\n}\nfunction segmentsToDate(parsedDate, parsedTime) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const year = ((_a = parsedDate.year) === null || _a === void 0 ? void 0 : _a.length) === 2 ? `20${parsedDate.year}` : parsedDate.year;\n  const date = new Date(Number(year !== null && year !== void 0 ? year : '0'), Number((_b = parsedDate.month) !== null && _b !== void 0 ? _b : '1') - 1, Number((_c = parsedDate.day) !== null && _c !== void 0 ? _c : '1'), Number((_d = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.hours) !== null && _d !== void 0 ? _d : '0'), Number((_e = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.minutes) !== null && _e !== void 0 ? _e : '0'), Number((_f = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.seconds) !== null && _f !== void 0 ? _f : '0'), Number((_g = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.milliseconds) !== null && _g !== void 0 ? _g : '0')); // needed for years less than 1900\n\n  date.setFullYear(Number(year !== null && year !== void 0 ? year : '0'));\n  return date;\n}\nconst DATE_TIME_SEPARATOR = ', ';\nfunction toDateString({\n  day,\n  month,\n  year,\n  hours,\n  minutes,\n  seconds,\n  milliseconds\n}, dateMode, timeMode) {\n  var _a;\n  const safeYear = ((_a = dateMode.match(/y/g)) === null || _a === void 0 ? void 0 : _a.length) === 2 ? year === null || year === void 0 ? void 0 : year.slice(-2) : year;\n  const fullMode = dateMode + (timeMode ? DATE_TIME_SEPARATOR + timeMode : '');\n  return fullMode.replace(/d+/g, day !== null && day !== void 0 ? day : '').replace(/m+/g, month !== null && month !== void 0 ? month : '').replace(/y+/g, safeYear !== null && safeYear !== void 0 ? safeYear : '').replace(/H+/g, hours !== null && hours !== void 0 ? hours : '').replace(/MSS/g, milliseconds !== null && milliseconds !== void 0 ? milliseconds : '').replace(/M+/g, minutes !== null && minutes !== void 0 ? minutes : '').replace(/S+/g, seconds !== null && seconds !== void 0 ? seconds : '').replace(/^\\D+/g, '').replace(/\\D+$/g, '');\n}\nfunction padWithZeroesUntilValid(segmentValue, paddedMaxValue, prefixedZeroesCount = 0) {\n  if (Number(segmentValue.padEnd(paddedMaxValue.length, '0')) <= Number(paddedMaxValue)) {\n    return {\n      validatedSegmentValue: segmentValue,\n      prefixedZeroesCount\n    };\n  }\n  if (segmentValue.endsWith('0')) {\n    // 00:|00 => Type 9 => 00:09|\n    return padWithZeroesUntilValid(`0${segmentValue.slice(0, paddedMaxValue.length - 1)}`, paddedMaxValue, prefixedZeroesCount + 1);\n  } // |19:00 => Type 2 => 2|0:00\n\n  return padWithZeroesUntilValid(`${segmentValue.slice(0, paddedMaxValue.length - 1)}0`, paddedMaxValue, prefixedZeroesCount);\n}\nconst dateMaxValues = {\n  day: 31,\n  month: 12,\n  year: 9999\n};\nfunction validateDateString({\n  dateString,\n  dateModeTemplate,\n  offset,\n  selection: [from, to]\n}) {\n  const parsedDate = parseDateString(dateString, dateModeTemplate);\n  const dateSegments = Object.entries(parsedDate);\n  const validatedDateSegments = {};\n  let paddedZeroes = 0;\n  for (const [segmentName, segmentValue] of dateSegments) {\n    const validatedDate = toDateString(validatedDateSegments, dateModeTemplate);\n    const maxSegmentValue = dateMaxValues[segmentName];\n    const fantomSeparator = validatedDate.length && 1;\n    const lastSegmentDigitIndex = offset + validatedDate.length + fantomSeparator + getDateSegmentValueLength(dateModeTemplate)[segmentName];\n    const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex === to;\n    if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {\n      // 3|1.10.2010 => Type 9 => 3|1.10.2010\n      return {\n        validatedDateString: '',\n        updatedSelection: [from, to]\n      }; // prevent changes\n    }\n    if (isLastSegmentDigitAdded && Number(segmentValue) < 1) {\n      // 31.0|1.2010 => Type 0 => 31.0|1.2010\n      return {\n        validatedDateString: '',\n        updatedSelection: [from, to]\n      }; // prevent changes\n    }\n    const {\n      validatedSegmentValue,\n      prefixedZeroesCount\n    } = padWithZeroesUntilValid(segmentValue, `${maxSegmentValue}`);\n    paddedZeroes += prefixedZeroesCount;\n    validatedDateSegments[segmentName] = validatedSegmentValue;\n  }\n  const validatedDateString = toDateString(validatedDateSegments, dateModeTemplate);\n  const addedDateSegmentSeparators = validatedDateString.length - dateString.length;\n  return {\n    validatedDateString,\n    updatedSelection: [from + paddedZeroes + addedDateSegmentSeparators, to + paddedZeroes + addedDateSegmentSeparators]\n  };\n}\n\n/**\r\n * Copy-pasted solution from lodash\r\n * @see https://lodash.com/docs/4.17.15#escapeRegExp\r\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nconst reHasRegExpChar = new RegExp(reRegExpChar.source);\nfunction escapeRegExp(str) {\n  return str && reHasRegExpChar.test(str) ? str.replace(reRegExpChar, '\\\\$&') : str;\n}\nfunction findCommonBeginningSubstr(a, b) {\n  let res = '';\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return res;\n    }\n    res += a[i];\n  }\n  return res;\n}\n\n/**\r\n * Returns current active element, including shadow dom\r\n *\r\n * @return element or null\r\n */\nfunction getFocused({\n  activeElement\n}) {\n  if (!(activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot)) {\n    return activeElement;\n  }\n  let element = activeElement.shadowRoot.activeElement;\n  while (element === null || element === void 0 ? void 0 : element.shadowRoot) {\n    element = element.shadowRoot.activeElement;\n  }\n  return element;\n}\nfunction identity(x) {\n  return x;\n}\nfunction isEmpty(entity) {\n  return !entity || typeof entity === 'object' && Object.keys(entity).length === 0;\n}\nfunction raiseSegmentValueToMin(segments, fullMode) {\n  const segmentsLength = getDateSegmentValueLength(fullMode);\n  return getObjectFromEntries(Object.entries(segments).map(([key, value]) => {\n    const segmentLength = segmentsLength[key];\n    return [key, value.length === segmentLength && value.match(/^0+$/) ? '1'.padStart(segmentLength, '0') : value];\n  }));\n}\nfunction createMinMaxDatePostprocessor({\n  dateModeTemplate,\n  min = DEFAULT_MIN_DATE,\n  max = DEFAULT_MAX_DATE,\n  rangeSeparator = '',\n  dateSegmentSeparator = '.'\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const endsWithRangeSeparator = rangeSeparator && value.endsWith(rangeSeparator);\n    const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n    let validatedValue = '';\n    for (const dateString of dateStrings) {\n      validatedValue += validatedValue ? rangeSeparator : '';\n      const parsedDate = parseDateString(dateString, dateModeTemplate);\n      if (!isDateStringComplete(dateString, dateModeTemplate)) {\n        const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n        const fixedValue = toDateString(fixedDate, dateModeTemplate);\n        const tail = dateString.endsWith(dateSegmentSeparator) ? dateSegmentSeparator : '';\n        validatedValue += fixedValue + tail;\n        continue;\n      }\n      const date = segmentsToDate(parsedDate);\n      const clampedDate = clamp(date, min, max);\n      validatedValue += toDateString(dateToSegments(clampedDate), dateModeTemplate);\n    }\n    return {\n      selection,\n      value: validatedValue + (endsWithRangeSeparator ? rangeSeparator : '')\n    };\n  };\n}\nfunction normalizeDatePreprocessor({\n  dateModeTemplate,\n  dateSegmentsSeparator,\n  rangeSeparator = ''\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const separator = rangeSeparator ? new RegExp(`${rangeSeparator}|-`) : DATE_TIME_SEPARATOR;\n    const possibleDates = data.split(separator);\n    const dates = data.includes(DATE_TIME_SEPARATOR) ? [possibleDates[0]] : possibleDates;\n    if (dates.every(date => date.trim().split(/\\D/).length === dateModeTemplate.split(dateSegmentsSeparator).length)) {\n      const newData = dates.map(date => normalizeDateString(date, dateModeTemplate, dateSegmentsSeparator)).join(rangeSeparator);\n      return {\n        elementState,\n        data: `${newData}${data.includes(DATE_TIME_SEPARATOR) ? DATE_TIME_SEPARATOR + possibleDates[1] || '' : ''}`\n      };\n    }\n    return {\n      elementState,\n      data\n    };\n  };\n}\nfunction normalizeDateString(dateString, template, separator) {\n  const dateSegments = dateString.split(/\\D/);\n  const templateSegments = template.split(separator);\n  const normalizedSegments = dateSegments.map((segment, index) => index === templateSegments.length - 1 ? segment : segment.padStart(templateSegments[index].length, '0'));\n  return normalizedSegments.join(separator);\n}\nfunction maskitoPostfixPostprocessorGenerator(postfix) {\n  const postfixRE = new RegExp(`${escapeRegExp(postfix)}$`);\n  return postfix ? ({\n    value,\n    selection\n  }, initialElementState) => {\n    if (!value && !initialElementState.value.endsWith(postfix)) {\n      // cases when developer wants input to be empty (programmatically)\n      return {\n        value,\n        selection\n      };\n    }\n    if (!value.endsWith(postfix) && !initialElementState.value.endsWith(postfix)) {\n      return {\n        selection,\n        value: value + postfix\n      };\n    }\n    const initialValueBeforePostfix = initialElementState.value.replace(postfixRE, '');\n    const postfixWasModified = initialElementState.selection[1] >= initialValueBeforePostfix.length;\n    const alreadyExistedValueBeforePostfix = findCommonBeginningSubstr(initialValueBeforePostfix, value);\n    return {\n      selection,\n      value: Array.from(postfix).reverse().reduce((newValue, char, index) => {\n        const i = newValue.length - 1 - index;\n        const isInitiallyMirroredChar = alreadyExistedValueBeforePostfix[i] === char && postfixWasModified;\n        return newValue[i] !== char || isInitiallyMirroredChar ? newValue.slice(0, i + 1) + char + newValue.slice(i + 1) : newValue;\n      }, value)\n    };\n  } : identity;\n}\nfunction maskitoPrefixPostprocessorGenerator(prefix) {\n  return prefix ? ({\n    value,\n    selection\n  }, initialElementState) => {\n    if (value.startsWith(prefix) ||\n    // already valid\n    !value && !initialElementState.value.startsWith(prefix) // cases when developer wants input to be empty\n    ) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [from, to] = selection;\n    const prefixedValue = Array.from(prefix).reduce((modifiedValue, char, i) => modifiedValue[i] === char ? modifiedValue : modifiedValue.slice(0, i) + char + modifiedValue.slice(i), value);\n    const addedCharsCount = prefixedValue.length - value.length;\n    return {\n      selection: [from + addedCharsCount, to + addedCharsCount],\n      value: prefixedValue\n    };\n  } : identity;\n}\nfunction createValidDatePreprocessor({\n  dateModeTemplate,\n  dateSegmentsSeparator,\n  rangeSeparator = ''\n}) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    if (data === dateSegmentsSeparator) {\n      return {\n        elementState,\n        data: selection[0] === value.length ? data : ''\n      };\n    }\n    if (POSSIBLE_DATE_RANGE_SEPARATOR.includes(data)) {\n      return {\n        elementState,\n        data: rangeSeparator\n      };\n    }\n    const newCharacters = data.replace(new RegExp(`[^\\\\d${escapeRegExp(dateSegmentsSeparator)}${rangeSeparator}]`, 'g'), '');\n    if (!newCharacters) {\n      return {\n        elementState,\n        data: ''\n      };\n    }\n    const [from, rawTo] = selection;\n    let to = rawTo + data.length;\n    const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n    const dateStrings = parseDateRangeString(newPossibleValue, dateModeTemplate, rangeSeparator);\n    let validatedValue = '';\n    const hasRangeSeparator = Boolean(rangeSeparator) && newPossibleValue.includes(rangeSeparator);\n    for (const dateString of dateStrings) {\n      const {\n        validatedDateString,\n        updatedSelection\n      } = validateDateString({\n        dateString,\n        dateModeTemplate,\n        offset: validatedValue ? validatedValue.length + rangeSeparator.length : 0,\n        selection: [from, to]\n      });\n      if (dateString && !validatedDateString) {\n        return {\n          elementState,\n          data: ''\n        }; // prevent changes\n      }\n      to = updatedSelection[1];\n      validatedValue += hasRangeSeparator && validatedValue ? rangeSeparator + validatedDateString : validatedDateString;\n    }\n    const newData = validatedValue.slice(from, to);\n    return {\n      elementState: {\n        selection,\n        value: validatedValue.slice(0, from) + newData.split(dateSegmentsSeparator).map(segment => '0'.repeat(segment.length)).join(dateSegmentsSeparator) + validatedValue.slice(to)\n      },\n      data: newData\n    };\n  };\n}\nfunction maskitoEventHandler(name, handler, eventListenerOptions) {\n  return (element, maskitoOptions) => {\n    const listener = () => handler(element, maskitoOptions);\n    element.addEventListener(name, listener, eventListenerOptions);\n    return () => element.removeEventListener(name, listener, eventListenerOptions);\n  };\n}\nfunction maskitoAddOnFocusPlugin(value) {\n  return maskitoEventHandler('focus', element => {\n    if (!element.value) {\n      element.value = value;\n      element.dispatchEvent(new Event('input'));\n    }\n  });\n}\nfunction maskitoCaretGuard(guard) {\n  return element => {\n    const document = element.ownerDocument;\n    let isPointerDown = 0;\n    const onPointerDown = () => isPointerDown++;\n    const onPointerUp = () => {\n      isPointerDown = Math.max(--isPointerDown, 0);\n    };\n    const listener = () => {\n      if (getFocused(document) !== element) {\n        return;\n      }\n      if (isPointerDown) {\n        return document.addEventListener('mouseup', listener, {\n          once: true,\n          passive: true\n        });\n      }\n      const start = element.selectionStart || 0;\n      const end = element.selectionEnd || 0;\n      const [fromLimit, toLimit] = guard(element.value, [start, end]);\n      if (fromLimit > start || toLimit < end) {\n        element.setSelectionRange(clamp(start, fromLimit, toLimit), clamp(end, fromLimit, toLimit));\n      }\n    };\n    document.addEventListener('selectionchange', listener, {\n      passive: true\n    });\n    element.addEventListener('mousedown', onPointerDown, {\n      passive: true\n    });\n    document.addEventListener('mouseup', onPointerUp, {\n      passive: true\n    });\n    return () => {\n      document.removeEventListener('selectionchange', listener);\n      document.removeEventListener('mousedown', onPointerDown);\n      document.removeEventListener('mouseup', onPointerUp);\n    };\n  };\n}\nfunction maskitoRejectEvent(element) {\n  const listener = () => {\n    const value = element.value;\n    element.addEventListener('beforeinput', event => {\n      if (event.defaultPrevented && value === element.value) {\n        element.dispatchEvent(new CustomEvent('maskitoReject', {\n          bubbles: true\n        }));\n      }\n    }, {\n      once: true\n    });\n  };\n  element.addEventListener('beforeinput', listener, true);\n  return () => element.removeEventListener('beforeinput', listener, true);\n}\nfunction maskitoRemoveOnBlurPlugin(value) {\n  return maskitoEventHandler('blur', element => {\n    if (element.value === value) {\n      element.value = '';\n      element.dispatchEvent(new Event('input'));\n    }\n  });\n}\nfunction maskitoWithPlaceholder(placeholder, focusedOnly = false) {\n  const removePlaceholder = value => {\n    for (let i = value.length - 1; i >= 0; i--) {\n      if (value[i] !== placeholder[i]) {\n        return value.slice(0, i + 1);\n      }\n    }\n    return '';\n  };\n  const plugins = [maskitoCaretGuard(value => [0, removePlaceholder(value).length])];\n  let focused = false;\n  if (focusedOnly) {\n    const focus = maskitoEventHandler('focus', element => {\n      focused = true;\n      element.value += placeholder.slice(element.value.length);\n      element.dispatchEvent(new Event('input'));\n    }, {\n      capture: true\n    });\n    const blur = maskitoEventHandler('blur', element => {\n      focused = false;\n      element.value = removePlaceholder(element.value);\n      element.dispatchEvent(new Event('input'));\n    }, {\n      capture: true\n    });\n    plugins.push(focus, blur);\n  }\n  return {\n    plugins,\n    removePlaceholder,\n    preprocessors: [({\n      elementState,\n      data\n    }) => {\n      const {\n        value,\n        selection\n      } = elementState;\n      return {\n        elementState: {\n          selection,\n          value: removePlaceholder(value)\n        },\n        data\n      };\n    }],\n    postprocessors: [({\n      value,\n      selection\n    }, initialElementState) => initialElementState.value && (focused || !focusedOnly) ? {\n      value: value + placeholder.slice(value.length),\n      selection\n    } : {\n      value,\n      selection\n    }]\n  };\n}\nfunction createZeroPlaceholdersPreprocessor() {\n  return ({\n    elementState\n  }, actionType) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    if (!value || isLastChar(value, selection)) {\n      return {\n        elementState\n      };\n    }\n    const [from, to] = selection;\n    const zeroes = value.slice(from, to).replace(/\\d/g, '0');\n    const newValue = value.slice(0, from) + zeroes + value.slice(to);\n    if (actionType === 'validation' || actionType === 'insert' && from === to) {\n      return {\n        elementState: {\n          selection,\n          value: newValue\n        }\n      };\n    }\n    return {\n      elementState: {\n        selection: actionType === 'deleteBackward' || actionType === 'insert' ? [from, from] : [to, to],\n        value: newValue\n      }\n    };\n  };\n}\nfunction isLastChar(value, [_, to]) {\n  return to === value.length;\n}\nfunction maskitoDateOptionsGenerator({\n  mode,\n  separator = '.',\n  max,\n  min\n}) {\n  const dateModeTemplate = mode.split('/').join(separator);\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: Array.from(dateModeTemplate).map(char => char === separator ? char : /\\d/),\n    overwriteMode: 'replace',\n    preprocessors: [createZeroPlaceholdersPreprocessor(), normalizeDatePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: separator\n    }), createValidDatePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: separator\n    })],\n    postprocessors: [createMinMaxDatePostprocessor({\n      min,\n      max,\n      dateModeTemplate,\n      dateSegmentSeparator: separator\n    })]\n  });\n}\nfunction createMinMaxRangeLengthPostprocessor({\n  dateModeTemplate,\n  rangeSeparator,\n  minLength,\n  maxLength,\n  max = DEFAULT_MAX_DATE\n}) {\n  if (isEmpty(minLength) && isEmpty(maxLength)) {\n    return identity;\n  }\n  return ({\n    value,\n    selection\n  }) => {\n    const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n    if (dateStrings.length !== 2 || dateStrings.some(date => !isDateStringComplete(date, dateModeTemplate))) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [fromDate, toDate] = dateStrings.map(dateString => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n    const minDistantToDate = appendDate(fromDate, Object.assign(Object.assign({}, minLength), {\n      // 06.02.2023 - 07.02.2023 => {minLength: {day: 3}} => 06.02.2023 - 08.02.2023\n      // \"from\"-day is included in the range\n      day: (minLength === null || minLength === void 0 ? void 0 : minLength.day) && minLength.day - 1\n    }));\n    const maxDistantToDate = !isEmpty(maxLength) ? appendDate(fromDate, Object.assign(Object.assign({}, maxLength), {\n      day: (maxLength === null || maxLength === void 0 ? void 0 : maxLength.day) && maxLength.day - 1\n    })) : max;\n    const minLengthClampedToDate = clamp(toDate, minDistantToDate, max);\n    const minMaxLengthClampedToDate = minLengthClampedToDate > maxDistantToDate ? maxDistantToDate : minLengthClampedToDate;\n    return {\n      selection,\n      value: dateStrings[0] + rangeSeparator + toDateString(dateToSegments(minMaxLengthClampedToDate), dateModeTemplate)\n    };\n  };\n}\nfunction createSwapDatesPostprocessor({\n  dateModeTemplate,\n  rangeSeparator\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n    const isDateRangeComplete = dateStrings.length === 2 && dateStrings.every(date => isDateStringComplete(date, dateModeTemplate));\n    const [from, to] = selection;\n    const caretAtTheEnd = from >= value.length;\n    const allValueSelected = from === 0 && to >= value.length; // dropping text inside with a pointer\n\n    if (!(caretAtTheEnd || allValueSelected) || !isDateRangeComplete) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [fromDate, toDate] = dateStrings.map(dateString => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n    return {\n      selection,\n      value: fromDate > toDate ? dateStrings.reverse().join(rangeSeparator) : value\n    };\n  };\n}\nfunction maskitoDateRangeOptionsGenerator({\n  mode,\n  separator = '.',\n  min,\n  max,\n  minLength,\n  maxLength,\n  dateSeparator = separator,\n  rangeSeparator = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`\n}) {\n  const dateModeTemplate = mode.split('/').join(dateSeparator);\n  const dateMask = Array.from(dateModeTemplate).map(char => char === dateSeparator ? char : /\\d/);\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: [...dateMask, ...Array.from(rangeSeparator), ...dateMask],\n    overwriteMode: 'replace',\n    preprocessors: [createZeroPlaceholdersPreprocessor(), normalizeDatePreprocessor({\n      dateModeTemplate,\n      rangeSeparator,\n      dateSegmentsSeparator: dateSeparator\n    }), createValidDatePreprocessor({\n      dateModeTemplate,\n      rangeSeparator,\n      dateSegmentsSeparator: dateSeparator\n    })],\n    postprocessors: [createMinMaxDatePostprocessor({\n      min,\n      max,\n      dateModeTemplate,\n      rangeSeparator,\n      dateSegmentSeparator: dateSeparator\n    }), createMinMaxRangeLengthPostprocessor({\n      dateModeTemplate,\n      minLength,\n      maxLength,\n      max,\n      rangeSeparator\n    }), createSwapDatesPostprocessor({\n      dateModeTemplate,\n      rangeSeparator\n    })]\n  });\n}\nfunction padTimeSegments(timeSegments) {\n  return getObjectFromEntries(Object.entries(timeSegments).map(([segmentName, segmentValue]) => [segmentName, `${segmentValue}`.padEnd(TIME_SEGMENT_VALUE_LENGTHS[segmentName], '0')]));\n}\n\n/**\r\n * @param timeString can be with/without fixed characters\r\n */\n\nfunction parseTimeString(timeString) {\n  const onlyDigits = timeString.replace(/\\D+/g, '');\n  const timeSegments = {\n    hours: onlyDigits.slice(0, 2),\n    minutes: onlyDigits.slice(2, 4),\n    seconds: onlyDigits.slice(4, 6),\n    milliseconds: onlyDigits.slice(6, 9)\n  };\n  return getObjectFromEntries(Object.entries(timeSegments).filter(([_, value]) => Boolean(value)));\n}\nfunction toTimeString({\n  hours = '',\n  minutes = '',\n  seconds = '',\n  milliseconds = ''\n}) {\n  const mm = minutes && `:${minutes}`;\n  const ss = seconds && `:${seconds}`;\n  const ms = milliseconds && `.${milliseconds}`;\n  return `${hours}${mm}${ss}${ms}`;\n}\nconst TRAILING_TIME_SEGMENT_SEPARATOR_REG = new RegExp(`[${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]$`);\nfunction validateTimeString({\n  timeString,\n  paddedMaxValues,\n  offset,\n  selection: [from, to]\n}) {\n  const parsedTime = parseTimeString(timeString);\n  const possibleTimeSegments = Object.entries(parsedTime);\n  const validatedTimeSegments = {};\n  let paddedZeroes = 0;\n  for (const [segmentName, segmentValue] of possibleTimeSegments) {\n    const validatedTime = toTimeString(validatedTimeSegments);\n    const maxSegmentValue = paddedMaxValues[segmentName];\n    const fantomSeparator = validatedTime.length && 1;\n    const lastSegmentDigitIndex = offset + validatedTime.length + fantomSeparator + TIME_SEGMENT_VALUE_LENGTHS[segmentName];\n    const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex <= to;\n    if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {\n      // 2|0:00 => Type 9 => 2|0:00\n      return {\n        validatedTimeString: '',\n        updatedTimeSelection: [from, to]\n      }; // prevent changes\n    }\n    const {\n      validatedSegmentValue,\n      prefixedZeroesCount\n    } = padWithZeroesUntilValid(segmentValue, `${maxSegmentValue}`);\n    paddedZeroes += prefixedZeroesCount;\n    validatedTimeSegments[segmentName] = validatedSegmentValue;\n  }\n  const [trailingSegmentSeparator = ''] = timeString.match(TRAILING_TIME_SEGMENT_SEPARATOR_REG) || [];\n  const validatedTimeString = toTimeString(validatedTimeSegments) + trailingSegmentSeparator;\n  const addedDateSegmentSeparators = Math.max(validatedTimeString.length - timeString.length, 0);\n  return {\n    validatedTimeString,\n    updatedTimeSelection: [from + paddedZeroes + addedDateSegmentSeparators, to + paddedZeroes + addedDateSegmentSeparators]\n  };\n}\nfunction isDateTimeStringComplete(dateTimeString, dateMode, timeMode) {\n  return dateTimeString.length >= dateMode.length + timeMode.length + DATE_TIME_SEPARATOR.length && dateTimeString.split(DATE_TIME_SEPARATOR)[0].split(/\\D/).every(segment => !segment.match(/^0+$/));\n}\nfunction parseDateTimeString(dateTime, dateModeTemplate) {\n  const hasSeparator = dateTime.includes(DATE_TIME_SEPARATOR);\n  return [dateTime.slice(0, dateModeTemplate.length), dateTime.slice(hasSeparator ? dateModeTemplate.length + DATE_TIME_SEPARATOR.length : dateModeTemplate.length)];\n}\nfunction createMinMaxDateTimePostprocessor({\n  dateModeTemplate,\n  timeMode,\n  min = DEFAULT_MIN_DATE,\n  max = DEFAULT_MAX_DATE\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const [dateString, timeString] = parseDateTimeString(value, dateModeTemplate);\n    const parsedDate = parseDateString(dateString, dateModeTemplate);\n    const parsedTime = parseTimeString(timeString);\n    if (!isDateTimeStringComplete(value, dateModeTemplate, timeMode)) {\n      const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n      const {\n        year,\n        month,\n        day\n      } = isDateStringComplete(dateString, dateModeTemplate) ? dateToSegments(clamp(segmentsToDate(fixedDate), min, max)) : fixedDate;\n      const fixedValue = toDateString(Object.assign({\n        year,\n        month,\n        day\n      }, parsedTime), dateModeTemplate, timeMode);\n      const tail = value.slice(fixedValue.length);\n      return {\n        selection,\n        value: fixedValue + tail\n      };\n    }\n    const date = segmentsToDate(parsedDate, parsedTime);\n    const clampedDate = clamp(date, min, max);\n    const validatedValue = toDateString(dateToSegments(clampedDate), dateModeTemplate, timeMode);\n    return {\n      selection,\n      value: validatedValue\n    };\n  };\n}\nfunction createValidDateTimePreprocessor({\n  dateModeTemplate,\n  dateSegmentsSeparator\n}) {\n  const invalidCharsRegExp = new RegExp(`[^\\\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}${escapeRegExp(dateSegmentsSeparator)}]+`);\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    if (data === dateSegmentsSeparator) {\n      return {\n        elementState,\n        data: selection[0] === value.length ? data : ''\n      };\n    }\n    if (POSSIBLE_DATE_TIME_SEPARATOR.includes(data)) {\n      return {\n        elementState,\n        data: DATE_TIME_SEPARATOR\n      };\n    }\n    const newCharacters = data.replace(invalidCharsRegExp, '');\n    if (!newCharacters) {\n      return {\n        elementState,\n        data: ''\n      };\n    }\n    const [from, rawTo] = selection;\n    let to = rawTo + data.length;\n    const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n    const [dateString, timeString] = parseDateTimeString(newPossibleValue, dateModeTemplate);\n    let validatedValue = '';\n    const hasDateTimeSeparator = newPossibleValue.includes(DATE_TIME_SEPARATOR);\n    const {\n      validatedDateString,\n      updatedSelection\n    } = validateDateString({\n      dateString,\n      dateModeTemplate,\n      offset: 0,\n      selection: [from, to]\n    });\n    if (dateString && !validatedDateString) {\n      return {\n        elementState,\n        data: ''\n      }; // prevent changes\n    }\n    to = updatedSelection[1];\n    validatedValue += validatedDateString;\n    const paddedMaxValues = padTimeSegments(DEFAULT_TIME_SEGMENT_MAX_VALUES);\n    const {\n      validatedTimeString,\n      updatedTimeSelection\n    } = validateTimeString({\n      timeString,\n      paddedMaxValues,\n      offset: validatedValue.length + DATE_TIME_SEPARATOR.length,\n      selection: [from, to]\n    });\n    if (timeString && !validatedTimeString) {\n      return {\n        elementState,\n        data: ''\n      }; // prevent changes\n    }\n    to = updatedTimeSelection[1];\n    validatedValue += hasDateTimeSeparator ? DATE_TIME_SEPARATOR + validatedTimeString : validatedTimeString;\n    const newData = validatedValue.slice(from, to);\n    return {\n      elementState: {\n        selection,\n        value: validatedValue.slice(0, from) + newData.split(dateSegmentsSeparator).map(segment => '0'.repeat(segment.length)).join(dateSegmentsSeparator) + validatedValue.slice(to)\n      },\n      data: newData\n    };\n  };\n}\nfunction maskitoDateTimeOptionsGenerator({\n  dateMode,\n  timeMode,\n  dateSeparator = '.',\n  min,\n  max\n}) {\n  const dateModeTemplate = dateMode.split('/').join(dateSeparator);\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: [...Array.from(dateModeTemplate).map(char => char === dateSeparator ? char : /\\d/), ...DATE_TIME_SEPARATOR.split(''), ...Array.from(timeMode).map(char => TIME_FIXED_CHARACTERS.includes(char) ? char : /\\d/)],\n    overwriteMode: 'replace',\n    preprocessors: [createZeroPlaceholdersPreprocessor(), normalizeDatePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: dateSeparator\n    }), createValidDateTimePreprocessor({\n      dateModeTemplate,\n      dateSegmentsSeparator: dateSeparator\n    })],\n    postprocessors: [createMinMaxDateTimePostprocessor({\n      min,\n      max,\n      dateModeTemplate,\n      timeMode\n    })]\n  });\n}\nfunction generateMaskExpression({\n  decimalSeparator,\n  isNegativeAllowed,\n  precision,\n  thousandSeparator,\n  prefix,\n  postfix,\n  decimalPseudoSeparators = [],\n  pseudoMinuses = []\n}) {\n  const computedPrefix = computeAllOptionalCharsRegExp(prefix);\n  const digit = '\\\\d';\n  const optionalMinus = isNegativeAllowed ? `[${CHAR_MINUS}${pseudoMinuses.map(x => `\\\\${x}`).join('')}]?` : '';\n  const integerPart = thousandSeparator ? `[${digit}${escapeRegExp(thousandSeparator).replace(/\\s/g, '\\\\s')}]*` : `[${digit}]*`;\n  const decimalPart = precision > 0 ? `([${escapeRegExp(decimalSeparator)}${decimalPseudoSeparators.map(escapeRegExp).join('')}]${digit}{0,${Number.isFinite(precision) ? precision : ''}})?` : '';\n  const computedPostfix = computeAllOptionalCharsRegExp(postfix);\n  return new RegExp(`^${computedPrefix}${optionalMinus}${integerPart}${decimalPart}${computedPostfix}$`);\n}\nfunction computeAllOptionalCharsRegExp(str) {\n  return str ? `${str.split('').map(char => `${escapeRegExp(char)}?`).join('')}` : '';\n}\nfunction maskitoParseNumber(maskedNumber, decimalSeparator = '.') {\n  const hasNegativeSign = !!maskedNumber.match(new RegExp(`^\\\\D*[${CHAR_MINUS}\\\\${CHAR_HYPHEN}${CHAR_EN_DASH}${CHAR_EM_DASH}]`));\n  const unmaskedNumber = maskedNumber.replace(new RegExp(`[^\\\\d${escapeRegExp(decimalSeparator)}]`, 'g'), '').replace(decimalSeparator, '.');\n  return unmaskedNumber ? Number((hasNegativeSign ? CHAR_HYPHEN : '') + unmaskedNumber) : NaN;\n}\n\n/**\r\n * Convert number to string with replacing exponent part on decimals\r\n *\r\n * @param value the number\r\n * @return string representation of a number\r\n */\nfunction stringifyNumberWithoutExp(value) {\n  const valueAsString = String(value);\n  const [numberPart, expPart] = valueAsString.split('e-');\n  let valueWithoutExp = valueAsString;\n  if (expPart) {\n    const [, fractionalPart] = numberPart.split('.');\n    const decimalDigits = Number(expPart) + ((fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) || 0);\n    valueWithoutExp = value.toFixed(decimalDigits);\n  }\n  return valueWithoutExp;\n}\nfunction validateDecimalPseudoSeparators({\n  decimalSeparator,\n  thousandSeparator,\n  decimalPseudoSeparators = DEFAULT_DECIMAL_PSEUDO_SEPARATORS\n}) {\n  return decimalPseudoSeparators.filter(char => char !== thousandSeparator && char !== decimalSeparator);\n}\n\n/**\r\n * If `decimalZeroPadding` is `true`, it pads decimal part with zeroes\r\n * (until number of digits after decimalSeparator is equal to the `precision`).\r\n * @example 1,42 => (`precision` is equal to 4) => 1,4200.\r\n */\n\nfunction createDecimalZeroPaddingPostprocessor({\n  decimalSeparator,\n  precision,\n  decimalZeroPadding,\n  postfix\n}) {\n  if (precision <= 0 || !decimalZeroPadding) {\n    return identity;\n  }\n  const trailingPostfixRegExp = new RegExp(`${escapeRegExp(postfix)}$`);\n  return ({\n    value,\n    selection\n  }) => {\n    if (Number.isNaN(maskitoParseNumber(value, decimalSeparator))) {\n      return {\n        value,\n        selection\n      };\n    }\n    const [integerPart, decimalPart = ''] = value.replace(trailingPostfixRegExp, '').split(decimalSeparator);\n    return {\n      value: integerPart + decimalSeparator + decimalPart.padEnd(precision, '0') + postfix,\n      selection\n    };\n  };\n}\n\n/**\r\n * This preprocessor works only once at initialization phase (when `new Maskito(...)` is executed).\r\n * This preprocessor helps to avoid conflicts during transition from one mask to another (for the same input).\r\n * For example, the developer changes postfix (or other mask's props) during run-time.\r\n * ```\r\n * let maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' year'});\r\n * // [3 seconds later]\r\n * maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' years'});\r\n * ```\r\n */\n\nfunction createInitializationOnlyPreprocessor({\n  decimalSeparator,\n  decimalPseudoSeparators,\n  pseudoMinuses\n}) {\n  let isInitializationPhase = true;\n  const cleanNumberMask = generateMaskExpression({\n    decimalSeparator,\n    decimalPseudoSeparators,\n    pseudoMinuses,\n    prefix: '',\n    postfix: '',\n    thousandSeparator: '',\n    precision: Infinity,\n    isNegativeAllowed: true\n  });\n  return ({\n    elementState,\n    data\n  }) => {\n    if (!isInitializationPhase) {\n      return {\n        elementState,\n        data\n      };\n    }\n    isInitializationPhase = false;\n    return {\n      elementState: maskitoTransform(elementState, {\n        mask: cleanNumberMask\n      }),\n      data\n    };\n  };\n}\n\n/**\r\n * It removes repeated leading zeroes for integer part.\r\n * @example 0,|00005 => Backspace => |5\r\n * @example -0,|00005 => Backspace => -|5\r\n * @example User types \"000000\" => 0|\r\n * @example 0| => User types \"5\" => 5|\r\n */\n\nfunction createLeadingZeroesValidationPostprocessor(decimalSeparator, thousandSeparator) {\n  const trimLeadingZeroes = value => {\n    const escapedThousandSeparator = escapeRegExp(thousandSeparator);\n    return value.replace(\n    // all leading zeroes followed by another zero\n    new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=0)`), '$1').replace(\n    // zero followed by not-zero digit\n    new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=[1-9])`), '$1');\n  };\n  const countTrimmedZeroesBefore = (value, index) => {\n    const valueBefore = value.slice(0, index);\n    const followedByZero = value.slice(index).startsWith('0');\n    return valueBefore.length - trimLeadingZeroes(valueBefore).length + (followedByZero ? 1 : 0);\n  };\n  return ({\n    value,\n    selection\n  }) => {\n    const [from, to] = selection;\n    const hasDecimalSeparator = value.includes(decimalSeparator);\n    const [integerPart, decimalPart = ''] = value.split(decimalSeparator);\n    const zeroTrimmedIntegerPart = trimLeadingZeroes(integerPart);\n    if (integerPart === zeroTrimmedIntegerPart) {\n      return {\n        value,\n        selection\n      };\n    }\n    const newFrom = from - countTrimmedZeroesBefore(value, from);\n    const newTo = to - countTrimmedZeroesBefore(value, to);\n    return {\n      value: zeroTrimmedIntegerPart + (hasDecimalSeparator ? decimalSeparator : '') + decimalPart,\n      selection: [Math.max(newFrom, 0), Math.max(newTo, 0)]\n    };\n  };\n}\n\n/**\r\n * This postprocessor is connected with {@link createMinMaxPlugin}:\r\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\r\n */\n\nfunction createMinMaxPostprocessor({\n  min,\n  max,\n  decimalSeparator\n}) {\n  return ({\n    value,\n    selection\n  }) => {\n    const parsedNumber = maskitoParseNumber(value, decimalSeparator);\n    const limitedValue =\n    /**\r\n     * We cannot limit lower bound if user enters positive number.\r\n     * The same for upper bound and negative number.\r\n     * ___\r\n     * @example (min = 5)\r\n     * Empty input => Without this condition user cannot type 42 (the first digit will be rejected)\r\n     * ___\r\n     * @example (max = -10)\r\n     * Value is -10 => Without this condition user cannot delete 0 to enter another digit\r\n     */\n    parsedNumber > 0 ? Math.min(parsedNumber, max) : Math.max(parsedNumber, min);\n    if (!Number.isNaN(parsedNumber) && limitedValue !== parsedNumber) {\n      const newValue = `${limitedValue}`.replace('.', decimalSeparator).replace(CHAR_HYPHEN, CHAR_MINUS);\n      return {\n        value: newValue,\n        selection: [newValue.length, newValue.length]\n      };\n    }\n    return {\n      value,\n      selection\n    };\n  };\n}\n\n/**\r\n * Manage caret-navigation when user \"deletes\" non-removable digits or separators\r\n * @example 1,|42 => Backspace => 1|,42 (only if `decimalZeroPadding` is `true`)\r\n * @example 1|,42 => Delete => 1,|42 (only if `decimalZeroPadding` is `true`)\r\n * @example 0,|00 => Delete => 0,0|0 (only if `decimalZeroPadding` is `true`)\r\n * @example 1 |000 => Backspace => 1| 000 (always)\r\n */\nfunction createNonRemovableCharsDeletionPreprocessor({\n  decimalSeparator,\n  thousandSeparator,\n  decimalZeroPadding\n}) {\n  return ({\n    elementState,\n    data\n  }, actionType) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, to] = selection;\n    const selectedCharacters = value.slice(from, to);\n    const nonRemovableSeparators = decimalZeroPadding ? [decimalSeparator, thousandSeparator] : [thousandSeparator];\n    const areNonRemovableZeroesSelected = decimalZeroPadding && from > value.indexOf(decimalSeparator) && Boolean(selectedCharacters.match(/^0+$/gi));\n    if (actionType !== 'deleteBackward' && actionType !== 'deleteForward' || !nonRemovableSeparators.includes(selectedCharacters) && !areNonRemovableZeroesSelected) {\n      return {\n        elementState,\n        data\n      };\n    }\n    return {\n      elementState: {\n        value,\n        selection: actionType === 'deleteForward' ? [to, to] : [from, from]\n      },\n      data\n    };\n  };\n}\n\n/**\r\n * It pads integer part with zero if user types decimal separator (for empty input).\r\n * @example Empty input => User types \",\" (decimal separator) => 0,|\r\n */\n\nfunction createNotEmptyIntegerPartPreprocessor({\n  decimalSeparator,\n  precision\n}) {\n  const startWithDecimalSepRegExp = new RegExp(`^\\\\D*${escapeRegExp(decimalSeparator)}`);\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from] = selection;\n    if (precision <= 0 || value.includes(decimalSeparator) || !data.match(startWithDecimalSepRegExp)) {\n      return {\n        elementState,\n        data\n      };\n    }\n    const digitsBeforeCursor = value.slice(0, from).match(/\\d+/);\n    return {\n      elementState,\n      data: digitsBeforeCursor ? data : `0${data}`\n    };\n  };\n}\n\n/**\r\n * It replaces pseudo characters with valid one.\r\n * @example User types '.' (but separator is equal to comma) => dot is replaced with comma.\r\n * @example User types hyphen / en-dash / em-dash => it is replaced with minus.\r\n */\nfunction createPseudoCharactersPreprocessor(validCharacter, pseudoCharacters) {\n  const pseudoCharactersRegExp = new RegExp(`[${pseudoCharacters.join('')}]`, 'gi');\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    return {\n      elementState: {\n        selection,\n        value: value.replace(pseudoCharactersRegExp, validCharacter)\n      },\n      data: data.replace(pseudoCharactersRegExp, validCharacter)\n    };\n  };\n}\n\n/**\r\n * It rejects new typed decimal separator if it already exists in text field.\r\n * Behaviour is similar to native <input type=\"number\"> (Chrome).\r\n * @example 1|23,45 => Press comma (decimal separator) => 1|23,45 (do nothing).\r\n */\n\nfunction createRepeatedDecimalSeparatorPreprocessor(decimalSeparator) {\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, to] = selection;\n    return {\n      elementState,\n      data: !value.includes(decimalSeparator) || value.slice(from, to + 1).includes(decimalSeparator) ? data : data.replace(new RegExp(escapeRegExp(decimalSeparator), 'gi'), '')\n    };\n  };\n}\n\n/**\r\n * It adds symbol for separating thousands.\r\n * @example 1000000 => (thousandSeparator is equal to space) => 1 000 000.\r\n */\n\nfunction createThousandSeparatorPostprocessor({\n  thousandSeparator,\n  decimalSeparator,\n  prefix,\n  postfix\n}) {\n  if (!thousandSeparator) {\n    return identity;\n  }\n  const prefixReg = new RegExp(`^${escapeRegExp(prefix)}${CHAR_MINUS}?`);\n  const postfixReg = new RegExp(`${escapeRegExp(postfix)}$`);\n  const isAllSpaces = (...chars) => chars.every(x => /\\s/.test(x));\n  return ({\n    value,\n    selection\n  }) => {\n    const [integerPart, decimalPart = ''] = value.split(decimalSeparator);\n    const [initialFrom, initialTo] = selection;\n    let [from, to] = selection;\n    const cleanIntegerPart = integerPart.replace(prefixReg, '').replace(postfixReg, '');\n    const [integerPartPrefix = ''] = integerPart.match(prefixReg) || [];\n    const [integerPartPostfix = ''] = integerPart.match(postfixReg) || [];\n    const processedIntegerPart = Array.from(cleanIntegerPart).reduceRight((formattedValuePart, char, i) => {\n      const isLeadingThousandSeparator = !i && char === thousandSeparator;\n      const isPositionForSeparator = !isLeadingThousandSeparator && formattedValuePart.length && (formattedValuePart.length + 1) % 4 === 0;\n      if (isPositionForSeparator && (char === thousandSeparator || isAllSpaces(char, thousandSeparator))) {\n        return thousandSeparator + formattedValuePart;\n      }\n      if (char === thousandSeparator && !isPositionForSeparator) {\n        if (i && i <= initialFrom) {\n          from--;\n        }\n        if (i && i <= initialTo) {\n          to--;\n        }\n        return formattedValuePart;\n      }\n      if (!isPositionForSeparator) {\n        return char + formattedValuePart;\n      }\n      if (i <= initialFrom) {\n        from++;\n      }\n      if (i <= initialTo) {\n        to++;\n      }\n      return char + thousandSeparator + formattedValuePart;\n    }, '');\n    return {\n      value: integerPartPrefix + processedIntegerPart + integerPartPostfix + (value.includes(decimalSeparator) ? decimalSeparator : '') + decimalPart,\n      selection: [from, to]\n    };\n  };\n}\n\n/**\r\n * It drops decimal part if precision is zero.\r\n * @example User pastes '123.45' (but precision is zero) => 123\r\n */\n\nfunction createZeroPrecisionPreprocessor(precision, decimalSeparator) {\n  if (precision > 0) {\n    return identity;\n  }\n  const decimalPartRegExp = new RegExp(`${escapeRegExp(decimalSeparator)}.*$`, 'g');\n  return ({\n    elementState,\n    data\n  }) => {\n    const {\n      value,\n      selection\n    } = elementState;\n    const [from, to] = selection;\n    const newValue = value.replace(decimalPartRegExp, '');\n    return {\n      elementState: {\n        selection: [Math.min(from, newValue.length), Math.min(to, newValue.length)],\n        value: newValue\n      },\n      data: data.replace(decimalPartRegExp, '')\n    };\n  };\n}\nconst DUMMY_SELECTION = [0, 0];\n/**\r\n * It removes repeated leading zeroes for integer part on blur-event.\r\n * @example 000000 => blur => 0\r\n * @example 00005 => blur => 5\r\n */\n\nfunction createLeadingZeroesValidationPlugin(decimalSeparator, thousandSeparator) {\n  const dropRepeatedLeadingZeroes = createLeadingZeroesValidationPostprocessor(decimalSeparator, thousandSeparator);\n  return maskitoEventHandler('blur', element => {\n    const newValue = dropRepeatedLeadingZeroes({\n      value: element.value,\n      selection: DUMMY_SELECTION\n    }, {\n      value: '',\n      selection: DUMMY_SELECTION\n    }).value;\n    if (element.value !== newValue) {\n      element.value = newValue;\n      element.dispatchEvent(new Event('input'));\n    }\n  }, {\n    capture: true\n  });\n}\n\n/**\r\n * This plugin is connected with {@link createMinMaxPostprocessor}:\r\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\r\n */\n\nfunction createMinMaxPlugin({\n  min,\n  max,\n  decimalSeparator\n}) {\n  return maskitoEventHandler('blur', (element, options) => {\n    const parsedNumber = maskitoParseNumber(element.value, decimalSeparator);\n    const clampedNumber = clamp(parsedNumber, min, max);\n    if (!Number.isNaN(parsedNumber) && parsedNumber !== clampedNumber) {\n      element.value = maskitoTransform(stringifyNumberWithoutExp(clampedNumber), options);\n      element.dispatchEvent(new Event('input'));\n    }\n  }, {\n    capture: true\n  });\n}\n\n/**\r\n * It pads EMPTY integer part with zero if decimal parts exists.\r\n * It works on blur event only!\r\n * @example 1|,23 => Backspace => Blur => 0,23\r\n */\n\nfunction createNotEmptyIntegerPlugin(decimalSeparator) {\n  return maskitoEventHandler('blur', element => {\n    const newValue = element.value.replace(new RegExp(`^(\\\\D+)?${escapeRegExp(decimalSeparator)}`), `$10${decimalSeparator}`);\n    if (newValue !== element.value) {\n      element.value = newValue;\n      element.dispatchEvent(new Event('input'));\n    }\n  }, {\n    capture: true\n  });\n}\nfunction maskitoNumberOptionsGenerator({\n  max = Number.MAX_SAFE_INTEGER,\n  min = Number.MIN_SAFE_INTEGER,\n  precision = 0,\n  thousandSeparator = CHAR_NO_BREAK_SPACE,\n  decimalSeparator = '.',\n  decimalPseudoSeparators,\n  decimalZeroPadding = false,\n  prefix = '',\n  postfix = ''\n} = {}) {\n  const pseudoMinuses = [CHAR_HYPHEN, CHAR_EN_DASH, CHAR_EM_DASH].filter(char => char !== thousandSeparator && char !== decimalSeparator);\n  const validatedDecimalPseudoSeparators = validateDecimalPseudoSeparators({\n    decimalSeparator,\n    thousandSeparator,\n    decimalPseudoSeparators\n  });\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: generateMaskExpression({\n      decimalSeparator,\n      precision,\n      thousandSeparator,\n      prefix,\n      postfix,\n      isNegativeAllowed: min < 0\n    }),\n    preprocessors: [createInitializationOnlyPreprocessor({\n      decimalSeparator,\n      decimalPseudoSeparators: validatedDecimalPseudoSeparators,\n      pseudoMinuses\n    }), createPseudoCharactersPreprocessor(CHAR_MINUS, pseudoMinuses), createPseudoCharactersPreprocessor(decimalSeparator, validatedDecimalPseudoSeparators), createNotEmptyIntegerPartPreprocessor({\n      decimalSeparator,\n      precision\n    }), createNonRemovableCharsDeletionPreprocessor({\n      decimalSeparator,\n      decimalZeroPadding,\n      thousandSeparator\n    }), createZeroPrecisionPreprocessor(precision, decimalSeparator), createRepeatedDecimalSeparatorPreprocessor(decimalSeparator)],\n    postprocessors: [createMinMaxPostprocessor({\n      decimalSeparator,\n      min,\n      max\n    }), maskitoPrefixPostprocessorGenerator(prefix), maskitoPostfixPostprocessorGenerator(postfix), createThousandSeparatorPostprocessor({\n      decimalSeparator,\n      thousandSeparator,\n      prefix,\n      postfix\n    }), createDecimalZeroPaddingPostprocessor({\n      decimalSeparator,\n      decimalZeroPadding,\n      precision,\n      postfix\n    })],\n    plugins: [createLeadingZeroesValidationPlugin(decimalSeparator, thousandSeparator), createNotEmptyIntegerPlugin(decimalSeparator), createMinMaxPlugin({\n      min,\n      max,\n      decimalSeparator\n    })],\n    overwriteMode: decimalZeroPadding ? ({\n      value,\n      selection: [from]\n    }) => from <= value.indexOf(decimalSeparator) ? 'shift' : 'replace' : 'shift'\n  });\n}\nfunction createMaxValidationPreprocessor(timeSegmentMaxValues) {\n  const paddedMaxValues = padTimeSegments(timeSegmentMaxValues);\n  const invalidCharsRegExp = new RegExp(`[^\\\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]+`);\n  return ({\n    elementState,\n    data\n  }, actionType) => {\n    if (actionType === 'deleteBackward' || actionType === 'deleteForward') {\n      return {\n        elementState,\n        data\n      };\n    }\n    const {\n      value,\n      selection\n    } = elementState;\n    if (actionType === 'validation') {\n      const {\n        validatedTimeString,\n        updatedTimeSelection\n      } = validateTimeString({\n        timeString: value,\n        paddedMaxValues,\n        offset: 0,\n        selection\n      });\n      return {\n        elementState: {\n          value: validatedTimeString,\n          selection: updatedTimeSelection\n        },\n        data\n      };\n    }\n    const newCharacters = data.replace(invalidCharsRegExp, '');\n    const [from, rawTo] = selection;\n    let to = rawTo + newCharacters.length; // to be conformed with `overwriteMode: replace`\n\n    const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n    const {\n      validatedTimeString,\n      updatedTimeSelection\n    } = validateTimeString({\n      timeString: newPossibleValue,\n      paddedMaxValues,\n      offset: 0,\n      selection: [from, to]\n    });\n    if (newPossibleValue && !validatedTimeString) {\n      return {\n        elementState,\n        data: ''\n      }; // prevent changes\n    }\n    to = updatedTimeSelection[1];\n    const newData = validatedTimeString.slice(from, to);\n    return {\n      elementState: {\n        selection,\n        value: validatedTimeString.slice(0, from) + '0'.repeat(newData.length) + validatedTimeString.slice(to)\n      },\n      data: newData\n    };\n  };\n}\nfunction maskitoTimeOptionsGenerator({\n  mode,\n  timeSegmentMaxValues = {}\n}) {\n  const enrichedTimeSegmentMaxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n  return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), {\n    mask: Array.from(mode).map(char => TIME_FIXED_CHARACTERS.includes(char) ? char : /\\d/),\n    preprocessors: [createZeroPlaceholdersPreprocessor(), createMaxValidationPreprocessor(enrichedTimeSegmentMaxValues)],\n    overwriteMode: 'replace'\n  });\n}\nexport { maskitoAddOnFocusPlugin, maskitoCaretGuard, maskitoDateOptionsGenerator, maskitoDateRangeOptionsGenerator, maskitoDateTimeOptionsGenerator, maskitoEventHandler, maskitoNumberOptionsGenerator, maskitoParseNumber, maskitoPostfixPostprocessorGenerator, maskitoPrefixPostprocessorGenerator, maskitoRejectEvent, maskitoRemoveOnBlurPlugin, maskitoTimeOptionsGenerator, maskitoWithPlaceholder };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}