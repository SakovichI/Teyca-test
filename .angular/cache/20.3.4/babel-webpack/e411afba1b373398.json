{"ast":null,"code":"import { Observable, fromEvent, merge, concat, pipe, timer, EMPTY } from 'rxjs';\nimport { startWith, take, map, endWith, takeWhile, repeat, switchMap, distinctUntilChanged, shareReplay, filter, ignoreElements, withLatestFrom, tap } from 'rxjs/operators';\nimport { TuiOwnerDocumentException, TuiValuePresentException } from '@taiga-ui/cdk/exceptions';\nimport { tuiIsPresent, tuiGetOriginalArrayFromQueryList } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { ALWAYS_FALSE_HANDLER } from '@taiga-ui/cdk/constants';\nimport { tuiIsFalsy } from '@taiga-ui/cdk/utils';\nimport { tuiIsNativeFocused } from '@taiga-ui/cdk/utils/focus';\n\n/**\n * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)\n */\nfunction tuiControlValue(control) {\n  return new Observable(subscriber => {\n    var _a;\n    return (_a = control === null || control === void 0 ? void 0 : control.valueChanges) === null || _a === void 0 ? void 0 : _a.pipe(startWith(control.value)).subscribe(subscriber);\n  });\n}\nfunction tuiTypedFromEvent(target, event, options = {}) {\n  /**\n   * @note:\n   * in RxJS 7 type signature `TuiTypedEventTarget<E>` !== `HasEventTargetAddRemove<E>`\n   */\n  return fromEvent(target, event, options);\n}\n\n/**\n * Letting go of the mouse after it was pressed\n * @param target\n */\nfunction tuiMouseDragFinishFrom(target) {\n  return merge(tuiTypedFromEvent(target, 'mouseup'), tuiTypedFromEvent(target, 'dragend'));\n}\n\n// TODO: change type in v4.0\n// eslint-disable-next-line no-restricted-syntax\nvar TuiDragStage = /*#__PURE__*/function (TuiDragStage) {\n  TuiDragStage[TuiDragStage[\"Start\"] = 0] = \"Start\";\n  TuiDragStage[TuiDragStage[\"Continues\"] = 1] = \"Continues\";\n  TuiDragStage[TuiDragStage[\"End\"] = 2] = \"End\";\n  return TuiDragStage;\n}(TuiDragStage || {});\nclass TuiDragState {\n  constructor(stage, event) {\n    this.stage = stage;\n    this.event = event;\n  }\n}\nfunction tuiDragAndDropFrom(element) {\n  const {\n    ownerDocument\n  } = element;\n  if (!ownerDocument) {\n    throw new TuiOwnerDocumentException();\n  }\n  return concat(tuiTypedFromEvent(element, 'mousedown').pipe(take(1), map(event => new TuiDragState(TuiDragStage.Start, event))), merge(tuiTypedFromEvent(ownerDocument, 'mousemove').pipe(map(event => new TuiDragState(TuiDragStage.Continues, event))), tuiMouseDragFinishFrom(ownerDocument).pipe(take(1), map(event => new TuiDragState(TuiDragStage.End, event)), endWith(null))).pipe(takeWhile(tuiIsPresent))).pipe(repeat());\n}\n\n/**\n * Operator to set lifespan after which current value is considered obsolete\n */\nfunction tuiIsAlive(lifespan = 0) {\n  return pipe(switchMap(() => timer(lifespan).pipe(map(ALWAYS_FALSE_HANDLER), startWith(true))), distinctUntilChanged());\n}\nlet documentMouseUpIsAlive$;\nlet documentMouseDownIsAlive$;\nfunction tuiFocusVisibleObservable(element) {\n  const elementBlur$ = tuiTypedFromEvent(element, 'blur');\n  const {\n    ownerDocument\n  } = element;\n  if (!ownerDocument) {\n    throw new TuiOwnerDocumentException();\n  }\n  if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {\n    documentMouseUpIsAlive$ = tuiTypedFromEvent(ownerDocument, 'mouseup', {\n      capture: true\n    }).pipe(tuiIsAlive(), startWith(false), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    documentMouseDownIsAlive$ = tuiTypedFromEvent(ownerDocument, 'mousedown', {\n      capture: true\n    }).pipe(tuiIsAlive(), startWith(false), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n  }\n  return merge(\n  // focus events excluding ones that came right after mouse action\n  concat(tuiTypedFromEvent(element, 'focus').pipe(take(1)),\n  // filtering out blur events when element remains focused so that we ignore browser tab focus loss\n  elementBlur$.pipe(filter(() => !tuiIsNativeFocused(element)), take(1), ignoreElements())).pipe(repeat(), withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, (_event, elementActual, documentActual) => elementActual || documentActual), filter(tuiIsFalsy))).pipe(switchMap(() => elementBlur$.pipe(map(ALWAYS_FALSE_HANDLER), take(1), startWith(true))), distinctUntilChanged());\n}\nfunction tuiIfMap(project, predicate = Boolean) {\n  return pipe(switchMap(value => predicate(value) ? project(value) : EMPTY));\n}\nfunction tuiIsObserved(observable) {\n  var _a, _b;\n  return 'observed' in observable ? observable.observed : !!((_b = (_a = observable) === null || _a === void 0 ? void 0 : _a.observers) === null || _b === void 0 ? void 0 : _b.length);\n}\n\n/**\n * Converts changes observable of a QueryList to an Observable of arrays\n */\nfunction tuiQueryListChanges(queryList) {\n  return queryList.changes.pipe(startWith(null), map(() => tuiGetOriginalArrayFromQueryList(queryList)));\n}\n/**\n * @deprecated An alias, use {@link tuiQueryListChanges} instead\n */\nconst tuiItemsQueryListObservable = tuiQueryListChanges;\nfunction tuiMustBePresent() {\n  return map(value => {\n    if (!tuiIsPresent(value)) {\n      throw new TuiValuePresentException();\n    }\n    return value;\n  });\n}\nfunction tuiPressedObservable(element, {\n  onlyTrusted\n} = {\n  onlyTrusted: true\n}) {\n  const {\n    ownerDocument\n  } = element;\n  if (!ownerDocument) {\n    throw new TuiOwnerDocumentException();\n  }\n  return tuiTypedFromEvent(element, 'mousedown').pipe(filter(({\n    isTrusted\n  }) => isTrusted || !onlyTrusted), switchMap(() => tuiMouseDragFinishFrom(ownerDocument).pipe(map(ALWAYS_FALSE_HANDLER), take(1), startWith(true))));\n}\nfunction tuiPreventDefault() {\n  return tap(event => event.preventDefault());\n}\n\n/**\n * Normalizes scroll event in case element is `html` (document.documentElement)\n */\nfunction tuiScrollFrom(element) {\n  return tuiTypedFromEvent(element === element.ownerDocument.documentElement ? element.ownerDocument : element, 'scroll');\n}\nfunction tuiStopPropagation() {\n  return tap(e => {\n    e.stopPropagation();\n  });\n}\nfunction tuiWatch(cdr) {\n  return tap(() => {\n    cdr.markForCheck();\n  });\n}\nfunction tuiZonefull(zone) {\n  return source => new Observable(subscriber => source.subscribe({\n    next: value => zone.run(() => subscriber.next(value)),\n    error: error => zone.run(() => subscriber.error(error)),\n    complete: () => zone.run(() => subscriber.complete())\n  }));\n}\nfunction tuiZonefree(zone) {\n  return source => new Observable(subscriber => zone.runOutsideAngular(() => source.subscribe(subscriber)));\n}\nfunction tuiZoneOptimized(zone) {\n  return pipe(tuiZonefree(zone), tuiZonefull(zone));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiDragStage, TuiDragState, tuiControlValue, tuiDragAndDropFrom, tuiFocusVisibleObservable, tuiIfMap, tuiIsAlive, tuiIsObserved, tuiItemsQueryListObservable, tuiMouseDragFinishFrom, tuiMustBePresent, tuiPressedObservable, tuiPreventDefault, tuiQueryListChanges, tuiScrollFrom, tuiStopPropagation, tuiTypedFromEvent, tuiWatch, tuiZoneOptimized, tuiZonefree, tuiZonefull };\n//# sourceMappingURL=taiga-ui-cdk-observables.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}