{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, HostBinding, Output, Optional, Inject, Injectable, TemplateRef, ChangeDetectorRef, ComponentFactoryResolver, Injector, INJECTOR, ElementRef, ViewContainerRef, ViewChild } from '@angular/core';\nimport * as i1 from '@angular/forms';\nimport { NgModel } from '@angular/forms';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { EMPTY_FUNCTION } from '@taiga-ui/cdk/constants';\nimport { tuiIsPresent } from '@taiga-ui/cdk/utils';\nimport { Subject, merge, Observable, BehaviorSubject } from 'rxjs';\nimport { delay, startWith, map, filter, distinctUntilChanged, switchMap, takeUntil, ignoreElements, endWith, share } from 'rxjs/operators';\nimport { tuiIfMap } from '@taiga-ui/cdk/observables';\nimport { PolymorpheusTemplate } from '@tinkoff/ng-polymorpheus';\nimport * as i1$1 from '@taiga-ui/cdk/services';\nimport { TuiIdService } from '@taiga-ui/cdk/services';\nimport { TuiNoHostException } from '@taiga-ui/cdk/exceptions';\nimport { DOCUMENT } from '@angular/common';\nconst _c0 = [\"viewContainer\"];\nconst TUI = 'tui_interactive_';\n/**\n * The most basic class for interactive components\n */\nlet AbstractTuiInteractive = /*#__PURE__*/(() => {\n  class AbstractTuiInteractive {\n    constructor() {\n      this.pseudoHover = null;\n      this.pseudoActive = null;\n      this.pseudoFocus = null;\n      /**\n       * Determines if component is focusable with keyboard.\n       */\n      this.focusable = true;\n      this.nativeId = '';\n      /**\n       * Emits 'true' on focus and 'false' on blur.\n       */\n      this.focusedChange = new EventEmitter();\n      this.focusVisibleChange = new EventEmitter();\n      this.focusVisible = false;\n      this.autoIdString = `${TUI}${AbstractTuiInteractive.autoId++}${Date.now()}`;\n    }\n    get computedDisabled() {\n      return this.disabled;\n    }\n    get computedFocusable() {\n      return !this.computedDisabled && (this.focusable || this.focused);\n    }\n    get computedFocused() {\n      var _a;\n      return !this.computedDisabled && ((_a = this.pseudoFocus) !== null && _a !== void 0 ? _a : this.focused);\n    }\n    get computedFocusVisible() {\n      var _a;\n      return !this.computedDisabled && ((_a = this.pseudoFocus) !== null && _a !== void 0 ? _a : this.focusVisible);\n    }\n    // TODO: 3.0 Consider removing since native input is exposed\n    get id() {\n      return this.nativeId || this.autoIdString;\n    }\n    updateFocused(focused) {\n      this.focusedChange.emit(focused);\n    }\n    updateFocusVisible(focusVisible) {\n      if (this.focusVisible === focusVisible) {\n        return;\n      }\n      this.focusVisible = focusVisible;\n      this.focusVisibleChange.emit(focusVisible);\n    }\n  }\n  AbstractTuiInteractive.autoId = 0;\n  AbstractTuiInteractive.ɵfac = function AbstractTuiInteractive_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiInteractive)();\n  };\n  AbstractTuiInteractive.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiInteractive,\n    hostVars: 7,\n    hostBindings: function AbstractTuiInteractive_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"data-focused\", ctx.pseudoFocus);\n        i0.ɵɵclassProp(\"_disabled\", ctx.computedDisabled)(\"_focused\", ctx.computedFocused)(\"_focus-visible\", ctx.computedFocusVisible);\n      }\n    },\n    inputs: {\n      pseudoHover: \"pseudoHover\",\n      pseudoActive: \"pseudoActive\",\n      pseudoFocus: \"pseudoFocus\",\n      focusable: \"focusable\",\n      nativeId: \"nativeId\"\n    },\n    outputs: {\n      focusedChange: \"focusedChange\",\n      focusVisibleChange: \"focusVisibleChange\"\n    },\n    standalone: false\n  });\n  return AbstractTuiInteractive;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass AbstractTuiValueTransformer {}\n\n/**\n * Basic ControlValueAccessor class to build form components upon\n */\nlet AbstractTuiControl = /*#__PURE__*/(() => {\n  class AbstractTuiControl extends AbstractTuiInteractive {\n    constructor(ngControl, cdr, valueTransformer) {\n      super();\n      this.ngControl = ngControl;\n      this.cdr = cdr;\n      this.valueTransformer = valueTransformer;\n      this.refresh$ = new Subject();\n      this.onTouched = EMPTY_FUNCTION;\n      this.onChange = EMPTY_FUNCTION;\n      this.fallbackValue = this.getFallbackValue();\n      this.destroy$ = new Subject();\n      this.readOnly = false;\n      this.pseudoInvalid = null;\n      if (ngDevMode && this.ngControl === null) {\n        tuiAssert.assert(false, `NgControl not injected in ${this.constructor.name}!\\n`, 'Use [(ngModel)] or [formControl] or formControlName for correct work.');\n      }\n      if (this.ngControl) {\n        this.ngControl.valueAccessor = this;\n      }\n    }\n    get computedInvalid() {\n      return this.interactive && (this.pseudoInvalid !== null ? this.pseudoInvalid : this.touched && this.invalid);\n    }\n    get value() {\n      var _a;\n      return (_a = this.previousInternalValue) !== null && _a !== void 0 ? _a : this.fallbackValue;\n    }\n    set value(value) {\n      this.updateValue(value);\n    }\n    get safeCurrentValue() {\n      var _a;\n      return (_a = this.rawValue) !== null && _a !== void 0 ? _a : this.fallbackValue;\n    }\n    get invalid() {\n      return this.safeNgControlData(({\n        invalid\n      }) => invalid, false);\n    }\n    get valid() {\n      return this.safeNgControlData(({\n        valid\n      }) => valid, false);\n    }\n    get touched() {\n      return this.safeNgControlData(({\n        touched\n      }) => touched, false);\n    }\n    get disabled() {\n      return this.safeNgControlData(({\n        disabled\n      }) => disabled, false);\n    }\n    get interactive() {\n      return !this.readOnly && !this.computedDisabled;\n    }\n    get control() {\n      return this.safeNgControlData(({\n        control\n      }) => control, null);\n    }\n    get computedName() {\n      var _a, _b;\n      return (_b = (_a = this.controlName) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;\n    }\n    get controlName() {\n      var _a, _b, _c;\n      return (_c = (_b = (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : null;\n    }\n    get rawValue() {\n      const {\n        ngControl\n      } = this;\n      if (ngControl === null) {\n        return undefined;\n      }\n      const controlValue = ngControl instanceof NgModel && this.previousInternalValue === undefined ? ngControl.viewModel : ngControl.value;\n      return this.fromControlValue(controlValue);\n    }\n    ngOnInit() {\n      this.refresh$.pipe(delay(0), startWith(null), map(() => {\n        var _a;\n        return (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.control;\n      }), filter(tuiIsPresent), distinctUntilChanged(), switchMap(control => merge(control.valueChanges, control.statusChanges)), takeUntil(this.destroy$)).subscribe(() => {\n        this.refreshLocalValue(this.safeCurrentValue);\n      });\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    checkControlUpdate() {\n      this.cdr.markForCheck();\n    }\n    registerOnChange(onChange) {\n      this.onChange = componentValue => {\n        onChange(this.toControlValue(componentValue));\n      };\n      this.refresh$.next();\n    }\n    registerOnTouched(onTouched) {\n      this.onTouched = onTouched;\n    }\n    setDisabledState() {\n      this.checkControlUpdate();\n    }\n    writeValue(value) {\n      const controlValue = this.ngControl instanceof NgModel && this.previousInternalValue === undefined ? this.ngControl.model : value;\n      this.refreshLocalValue(this.fromControlValue(controlValue));\n    }\n    updateFocused(focused) {\n      if (!focused) {\n        this.controlMarkAsTouched();\n      }\n      super.updateFocused(focused);\n    }\n    /**\n     * @deprecated use `value` setter\n     */\n    updateValue(value) {\n      if (this.disabled || this.valueIdenticalComparator(this.value, value)) {\n        return;\n      }\n      this.previousInternalValue = value;\n      this.controlSetValue(value);\n    }\n    valueIdenticalComparator(oldValue, newValue) {\n      return oldValue === newValue;\n    }\n    safeNgControlData(extractor, defaultFieldValue) {\n      var _a;\n      return (_a = this.ngControl && extractor(this.ngControl)) !== null && _a !== void 0 ? _a : defaultFieldValue;\n    }\n    controlMarkAsTouched() {\n      this.onTouched();\n      this.checkControlUpdate();\n    }\n    controlSetValue(value) {\n      this.onChange(value);\n      this.checkControlUpdate();\n    }\n    refreshLocalValue(value) {\n      this.previousInternalValue = value;\n      this.checkControlUpdate();\n    }\n    fromControlValue(controlValue) {\n      return this.valueTransformer ? this.valueTransformer.fromControlValue(controlValue) : controlValue;\n    }\n    toControlValue(componentValue) {\n      return this.valueTransformer ? this.valueTransformer.toControlValue(componentValue) : componentValue;\n    }\n  }\n  AbstractTuiControl.ɵfac = function AbstractTuiControl_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiControl)(i0.ɵɵdirectiveInject(i1.NgControl, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(AbstractTuiValueTransformer, 8));\n  };\n  AbstractTuiControl.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiControl,\n    hostVars: 4,\n    hostBindings: function AbstractTuiControl_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"_readonly\", ctx.readOnly)(\"_invalid\", ctx.computedInvalid);\n      }\n    },\n    inputs: {\n      readOnly: \"readOnly\",\n      pseudoInvalid: \"pseudoInvalid\"\n    },\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return AbstractTuiControl;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction tuiAsControl(useExisting) {\n  return {\n    provide: AbstractTuiControl,\n    useExisting\n  };\n}\nlet AbstractTuiController = /*#__PURE__*/(() => {\n  class AbstractTuiController {\n    constructor() {\n      this.change$ = new Subject();\n    }\n    ngOnChanges() {\n      this.change$.next();\n    }\n  }\n  AbstractTuiController.ɵfac = function AbstractTuiController_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiController)();\n  };\n  AbstractTuiController.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiController,\n    standalone: false,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return AbstractTuiController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AbstractTuiDialogService = /*#__PURE__*/(() => {\n  class AbstractTuiDialogService extends Observable {\n    constructor(idService) {\n      super(observer => this.dialogs$.subscribe(observer));\n      this.idService = idService;\n      this.dialogs$ = new BehaviorSubject([]);\n    }\n    open(content, options = {}) {\n      return new Observable(observer => {\n        const completeWith = result => {\n          observer.next(result);\n          observer.complete();\n        };\n        const dialog = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), {\n          content,\n          completeWith,\n          $implicit: observer,\n          component: this.component,\n          createdAt: Date.now(),\n          id: this.idService.generate()\n        });\n        this.dialogs$.next([...this.dialogs$.value, dialog]);\n        return () => {\n          this.dialogs$.next(this.dialogs$.value.filter(item => item !== dialog));\n        };\n      });\n    }\n  }\n  AbstractTuiDialogService.ɵfac = function AbstractTuiDialogService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiDialogService)(i0.ɵɵinject(TuiIdService));\n  };\n  AbstractTuiDialogService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbstractTuiDialogService,\n    factory: AbstractTuiDialogService.ɵfac\n  });\n  return AbstractTuiDialogService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AbstractTuiDialogDirective = /*#__PURE__*/(() => {\n  class AbstractTuiDialogDirective extends PolymorpheusTemplate {\n    constructor(templateRef, cdr, service) {\n      super(templateRef, cdr);\n      this.service = service;\n      this.open$ = new Subject();\n      this.options = {};\n      this.open = false;\n      this.openChange = this.open$.pipe(distinctUntilChanged(), tuiIfMap(() => this.service.open(this, this.options).pipe(ignoreElements(), endWith(false))), share());\n    }\n    ngOnChanges() {\n      this.open$.next(this.open);\n    }\n  }\n  AbstractTuiDialogDirective.ɵfac = function AbstractTuiDialogDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiDialogDirective)(i0.ɵɵdirectiveInject(TemplateRef), i0.ɵɵdirectiveInject(ChangeDetectorRef), i0.ɵɵdirectiveInject(AbstractTuiDialogService));\n  };\n  AbstractTuiDialogDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiDialogDirective,\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return AbstractTuiDialogDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AbstractTuiMultipleControl = /*#__PURE__*/(() => {\n  class AbstractTuiMultipleControl extends AbstractTuiControl {\n    clear() {\n      this.value = [];\n    }\n    getFallbackValue() {\n      return [];\n    }\n  }\n  AbstractTuiMultipleControl.ɵfac = /* @__PURE__ */(() => {\n    let ɵAbstractTuiMultipleControl_BaseFactory;\n    return function AbstractTuiMultipleControl_Factory(__ngFactoryType__) {\n      return (ɵAbstractTuiMultipleControl_BaseFactory || (ɵAbstractTuiMultipleControl_BaseFactory = i0.ɵɵgetInheritedFactory(AbstractTuiMultipleControl)))(__ngFactoryType__ || AbstractTuiMultipleControl);\n    };\n  })();\n  AbstractTuiMultipleControl.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiMultipleControl,\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return AbstractTuiMultipleControl;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AbstractTuiNullableControl = /*#__PURE__*/(() => {\n  class AbstractTuiNullableControl extends AbstractTuiControl {\n    getFallbackValue() {\n      return null;\n    }\n  }\n  AbstractTuiNullableControl.ɵfac = /* @__PURE__ */(() => {\n    let ɵAbstractTuiNullableControl_BaseFactory;\n    return function AbstractTuiNullableControl_Factory(__ngFactoryType__) {\n      return (ɵAbstractTuiNullableControl_BaseFactory || (ɵAbstractTuiNullableControl_BaseFactory = i0.ɵɵgetInheritedFactory(AbstractTuiNullableControl)))(__ngFactoryType__ || AbstractTuiNullableControl);\n    };\n  })();\n  AbstractTuiNullableControl.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiNullableControl,\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return AbstractTuiNullableControl;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Abstract service for displaying portals\n */\nlet AbstractTuiPortalService = /*#__PURE__*/(() => {\n  class AbstractTuiPortalService {\n    get safeHost() {\n      if (!this.host) {\n        throw new TuiNoHostException();\n      }\n      return this.host;\n    }\n    attach(host) {\n      this.host = host;\n    }\n    add(component) {\n      return this.safeHost.addComponentChild(component);\n    }\n    remove({\n      hostView\n    }) {\n      if (!hostView.destroyed) {\n        hostView.destroy();\n      }\n    }\n    addTemplate(templateRef, context) {\n      return this.safeHost.addTemplateChild(templateRef, context);\n    }\n    removeTemplate(viewRef) {\n      if (!viewRef.destroyed) {\n        viewRef.destroy();\n      }\n    }\n  }\n  AbstractTuiPortalService.ɵfac = function AbstractTuiPortalService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiPortalService)();\n  };\n  AbstractTuiPortalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbstractTuiPortalService,\n    factory: AbstractTuiPortalService.ɵfac\n  });\n  return AbstractTuiPortalService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Abstract class for host element for dynamically created portals.\n */\nlet AbstractTuiPortalHostComponent = /*#__PURE__*/(() => {\n  class AbstractTuiPortalHostComponent {\n    constructor(injector, el, portalService) {\n      this.injector = injector;\n      this.el = el;\n      portalService.attach(this);\n    }\n    /** @deprecated unused, will be removed in 4.0 **/\n    get clientRect() {\n      return this.el.nativeElement.getBoundingClientRect();\n    }\n    addComponentChild(component) {\n      const parent = component.createInjector(this.injector);\n      const resolver = parent.get(ComponentFactoryResolver);\n      const factory = resolver.resolveComponentFactory(component.component);\n      // TODO: Remove in 4.0\n      const providers = [{\n        provide: AbstractTuiPortalHostComponent,\n        useValue: this\n      }];\n      const injector = Injector.create({\n        parent,\n        providers\n      });\n      const ref = this.vcr.createComponent(factory, undefined, injector);\n      ref.changeDetectorRef.detectChanges();\n      return ref;\n    }\n    addTemplateChild(templateRef, context) {\n      return this.vcr.createEmbeddedView(templateRef, context);\n    }\n  }\n  AbstractTuiPortalHostComponent.ɵfac = function AbstractTuiPortalHostComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiPortalHostComponent)(i0.ɵɵdirectiveInject(INJECTOR), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(AbstractTuiPortalService));\n  };\n  AbstractTuiPortalHostComponent.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiPortalHostComponent,\n    viewQuery: function AbstractTuiPortalHostComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.vcr = _t.first);\n      }\n    },\n    standalone: false\n  });\n  return AbstractTuiPortalHostComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use this abstract class to create your own toggleable themes.\n * A component extending this class must have CSS variables definitions\n * and have ViewEncapsulation set to NONE. A boolean input allows to\n * switch theme on or off.\n */\nlet AbstractTuiThemeSwitcher = /*#__PURE__*/(() => {\n  class AbstractTuiThemeSwitcher {\n    constructor(doc) {\n      this.doc = doc;\n      if (this.style !== null) {\n        this.addTheme();\n        return;\n      }\n      const styles = this.doc.head.querySelectorAll('style');\n      this.constructor.style = styles[styles.length - 1];\n    }\n    get style() {\n      return this.constructor.style;\n    }\n    ngOnDestroy() {\n      this.removeTheme();\n    }\n    addTheme() {\n      if (this.style) {\n        this.doc.head.appendChild(this.style);\n      }\n    }\n    removeTheme() {\n      var _a;\n      (_a = this.style) === null || _a === void 0 ? void 0 : _a.remove();\n    }\n  }\n  AbstractTuiThemeSwitcher.style = null;\n  AbstractTuiThemeSwitcher.ɵfac = function AbstractTuiThemeSwitcher_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AbstractTuiThemeSwitcher)(i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n  AbstractTuiThemeSwitcher.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiThemeSwitcher,\n    standalone: false\n  });\n  return AbstractTuiThemeSwitcher;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AbstractTuiControl, AbstractTuiController, AbstractTuiDialogDirective, AbstractTuiDialogService, AbstractTuiInteractive, AbstractTuiMultipleControl, AbstractTuiNullableControl, AbstractTuiPortalHostComponent, AbstractTuiPortalService, AbstractTuiThemeSwitcher, AbstractTuiValueTransformer, tuiAsControl };\n//# sourceMappingURL=taiga-ui-cdk-abstract.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}