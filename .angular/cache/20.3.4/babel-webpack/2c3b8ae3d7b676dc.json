{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, ComponentFactoryResolver, INJECTOR, Inject, ElementRef, ChangeDetectorRef, Self, NgZone, PLATFORM_ID } from '@angular/core';\nimport * as i1 from 'rxjs';\nimport { ReplaySubject, Observable, defer, merge, fromEvent, of, timer, from } from 'rxjs';\nimport { tuiFocusVisibleObservable, tuiWatch, tuiTypedFromEvent, tuiZoneOptimized, tuiZonefree, tuiPreventDefault } from '@taiga-ui/cdk/observables';\nimport { takeUntil, delay, throttleTime, map, startWith, distinctUntilChanged, switchMap, filter, pairwise, repeat, catchError, debounceTime, share, endWith, tap, shareReplay, scan } from 'rxjs/operators';\nimport { WINDOW, ANIMATION_FRAME, PERFORMANCE } from '@ng-web-apis/common';\nimport { POLLING_TIME, EMPTY_ARRAY } from '@taiga-ui/cdk/constants';\nimport { tuiGetElementObscures } from '@taiga-ui/cdk/utils/dom';\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\nimport { ResizeObserverService, RESIZE_OBSERVER_SUPPORT, RESIZE_OPTION_BOX } from '@ng-web-apis/resize-observer';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { tuiClamp } from '@taiga-ui/cdk/utils/math';\nimport { tuiEaseInOutQuad, tuiGetSwipeDirection, tuiIsPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { __awaiter } from 'tslib';\nimport { fromFetch } from 'rxjs/fetch';\nimport { TUI_SWIPE_OPTIONS, TUI_ZOOM_OPTIONS } from '@taiga-ui/cdk/tokens';\nimport { tuiDistanceBetweenTouches } from '@taiga-ui/cdk/utils';\n\n/**\n * @note:\n * Observable abstraction over ngOnDestroy to use with takeUntil\n *\n * Why we use `ReplaySubject` instead of `Subject`?\n * Well, we’ll use ReplaySubject to emit the last message in case\n * the subscription is ended after the component is destroyed.\n */\nlet TuiDestroyService = /*#__PURE__*/(() => {\n  class TuiDestroyService extends ReplaySubject {\n    constructor() {\n      super(1);\n    }\n    ngOnDestroy() {\n      this.next();\n    }\n  }\n  TuiDestroyService.ɵfac = function TuiDestroyService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDestroyService)();\n  };\n  TuiDestroyService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiDestroyService,\n    factory: TuiDestroyService.ɵfac\n  });\n  return TuiDestroyService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service to use styles with directives\n */\nlet TuiDirectiveStylesService = /*#__PURE__*/(() => {\n  class TuiDirectiveStylesService {\n    constructor(resolver, injector) {\n      this.resolver = resolver;\n      this.injector = injector;\n      this.map = new Map();\n    }\n    addComponent(component) {\n      if (!this.map.has(component)) {\n        this.map.set(component, this.resolver.resolveComponentFactory(component).create(this.injector));\n      }\n    }\n    ngOnDestroy() {\n      this.map.forEach(value => value.destroy());\n    }\n  }\n  TuiDirectiveStylesService.ɵfac = function TuiDirectiveStylesService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDirectiveStylesService)(i0.ɵɵinject(ComponentFactoryResolver), i0.ɵɵinject(INJECTOR));\n  };\n  TuiDirectiveStylesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiDirectiveStylesService,\n    factory: TuiDirectiveStylesService.ɵfac,\n    providedIn: 'root'\n  });\n  return TuiDirectiveStylesService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service to imitate :focus-visible\n * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)\n * in browsers that do not support it\n */\nlet TuiFocusVisibleService = /*#__PURE__*/(() => {\n  class TuiFocusVisibleService extends Observable {\n    constructor({\n      nativeElement\n    }, cdr, destroy$) {\n      super(subscriber => this.focusVisible$.subscribe(subscriber));\n      this.focusVisible$ = tuiFocusVisibleObservable(nativeElement).pipe(tuiWatch(cdr), takeUntil(destroy$));\n    }\n  }\n  TuiFocusVisibleService.ɵfac = function TuiFocusVisibleService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiFocusVisibleService)(i0.ɵɵinject(ElementRef), i0.ɵɵinject(ChangeDetectorRef), i0.ɵɵinject(TuiDestroyService, 2));\n  };\n  TuiFocusVisibleService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiFocusVisibleService,\n    factory: TuiFocusVisibleService.ɵfac\n  });\n  return TuiFocusVisibleService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TUI = 'tui_';\n/**\n * Generates unique ids\n */\nlet TuiIdService = /*#__PURE__*/(() => {\n  class TuiIdService {\n    generate() {\n      return `${TUI}${TuiIdService.autoId++}${Date.now()}`;\n    }\n  }\n  TuiIdService.autoId = 0;\n  TuiIdService.ɵfac = function TuiIdService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiIdService)();\n  };\n  TuiIdService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiIdService,\n    factory: TuiIdService.ɵfac,\n    providedIn: 'root'\n  });\n  return TuiIdService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service that subscribes to scroll events of all parent elements\n */\nlet TuiParentsScrollService = /*#__PURE__*/(() => {\n  class TuiParentsScrollService extends Observable {\n    constructor(\n    // Destructuring here causes memory leak\n    el, win) {\n      super(subscriber => this.callback$.subscribe(subscriber));\n      this.callback$ = defer(() => {\n        let {\n          nativeElement\n        } = el;\n        const eventTargets = [win, nativeElement];\n        while (nativeElement.parentElement) {\n          nativeElement = nativeElement.parentElement;\n          eventTargets.push(nativeElement);\n        }\n        return merge(...eventTargets.map(element => tuiTypedFromEvent(element, 'scroll')));\n      });\n    }\n  }\n  TuiParentsScrollService.ɵfac = function TuiParentsScrollService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiParentsScrollService)(i0.ɵɵinject(ElementRef), i0.ɵɵinject(WINDOW));\n  };\n  TuiParentsScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiParentsScrollService,\n    factory: TuiParentsScrollService.ɵfac\n  });\n  return TuiParentsScrollService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// @bad TODO: Consider Intersection Observer with fallback to current implementation\n/**\n * Service that monitors element visibility by subscribing to scrolls\n * and polling with set interval, returns either null or an array\n * of elements that overlap given element edges\n */\nlet TuiObscuredService = /*#__PURE__*/(() => {\n  class TuiObscuredService extends Observable {\n    constructor(parentsScroll$, {\n      nativeElement\n    }, zone, win, destroy$, animationFrame$) {\n      super(subscriber => this.obscured$.subscribe(subscriber));\n      this.obscured$ = merge(\n      // delay is added so it will not interfere with other listeners\n      merge(parentsScroll$, fromEvent(win, 'resize')).pipe(delay(0)), animationFrame$.pipe(throttleTime(POLLING_TIME))).pipe(map(() => tuiGetElementObscures(nativeElement)), startWith(null), distinctUntilChanged(), tuiZoneOptimized(zone), takeUntil(destroy$));\n    }\n  }\n  TuiObscuredService.ɵfac = function TuiObscuredService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiObscuredService)(i0.ɵɵinject(TuiParentsScrollService, 2), i0.ɵɵinject(ElementRef), i0.ɵɵinject(NgZone), i0.ɵɵinject(WINDOW), i0.ɵɵinject(TuiDestroyService, 2), i0.ɵɵinject(ANIMATION_FRAME));\n  };\n  TuiObscuredService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiObscuredService,\n    factory: TuiObscuredService.ɵfac\n  });\n  return TuiObscuredService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiPanService = /*#__PURE__*/(() => {\n  class TuiPanService extends Observable {\n    constructor({\n      nativeElement\n    }, doc) {\n      super(subscriber => {\n        merge(tuiTypedFromEvent(nativeElement, 'touchstart', {\n          passive: true\n        }), tuiTypedFromEvent(nativeElement, 'mousedown')).pipe(switchMap(() => merge(tuiTypedFromEvent(doc, 'touchmove', {\n          passive: true\n        }).pipe(filter(({\n          touches\n        }) => touches.length < 2), map(({\n          touches\n        }) => touches[0])), tuiTypedFromEvent(doc, 'mousemove'))), pairwise(), map(([first, second]) => {\n          const deltaX = second.clientX - first.clientX;\n          const deltaY = second.clientY - first.clientY;\n          return [deltaX, deltaY];\n        }),\n        // eslint-disable-next-line rxjs/no-unsafe-takeuntil\n        takeUntil(merge(tuiTypedFromEvent(doc, 'touchend'), tuiTypedFromEvent(doc, 'mouseup'))), repeat()).subscribe(subscriber);\n      });\n    }\n  }\n  TuiPanService.ɵfac = function TuiPanService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiPanService)(i0.ɵɵinject(ElementRef), i0.ɵɵinject(DOCUMENT));\n  };\n  TuiPanService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiPanService,\n    factory: TuiPanService.ɵfac\n  });\n  return TuiPanService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// TODO: Remove in 4.0 when Safari is bumped to 13\nlet TuiResizeService = /*#__PURE__*/(() => {\n  class TuiResizeService extends ResizeObserverService {\n    constructor(el, zone, destroy$, support, box, animationFrame$) {\n      super(el, zone, support, box);\n      return this.pipe(catchError(() =>\n      /**\n       * @note: if not supported ResizeObserver\n       * remove `catchError` after supports modern browsers\n       */\n      animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => `${el.nativeElement.clientWidth} ${el.nativeElement.clientHeight}`), distinctUntilChanged(), map(() => EMPTY_ARRAY))), debounceTime(0), tuiZonefree(zone), share(), takeUntil(destroy$));\n    }\n  }\n  TuiResizeService.ɵfac = function TuiResizeService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiResizeService)(i0.ɵɵinject(ElementRef), i0.ɵɵinject(NgZone), i0.ɵɵinject(TuiDestroyService, 2), i0.ɵɵinject(RESIZE_OBSERVER_SUPPORT), i0.ɵɵinject(RESIZE_OPTION_BOX), i0.ɵɵinject(ANIMATION_FRAME));\n  };\n  TuiResizeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiResizeService,\n    factory: TuiResizeService.ɵfac\n  });\n  return TuiResizeService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SCROLL_TIME = 300;\nfunction getX(elementOrWindow) {\n  return 'scrollX' in elementOrWindow ? elementOrWindow.scrollX : elementOrWindow.scrollLeft;\n}\nfunction getY(elementOrWindow) {\n  return 'scrollY' in elementOrWindow ? elementOrWindow.scrollY : elementOrWindow.scrollTop;\n}\nlet TuiScrollService = /*#__PURE__*/(() => {\n  class TuiScrollService {\n    constructor(performanceRef, animationFrame$) {\n      this.performanceRef = performanceRef;\n      this.animationFrame$ = animationFrame$;\n    }\n    scroll$(elementOrWindow, scrollTop, scrollLeft = getX(elementOrWindow), duration = SCROLL_TIME) {\n      ngDevMode && tuiAssert.assert(duration >= 0, 'Duration cannot be negative');\n      ngDevMode && tuiAssert.assert(scrollTop >= 0, 'scrollTop cannot be negative');\n      ngDevMode && tuiAssert.assert(scrollLeft >= 0, 'scrollLeft cannot be negative');\n      const initialTop = getY(elementOrWindow);\n      const initialLeft = getX(elementOrWindow);\n      const deltaTop = scrollTop - initialTop;\n      const deltaLeft = scrollLeft - initialLeft;\n      const observable = !duration ? of([scrollTop, scrollLeft]) : defer(() => of(this.performanceRef.now())).pipe(switchMap(start => this.animationFrame$.pipe(map(now => now - start))), map(elapsed => tuiEaseInOutQuad(tuiClamp(elapsed / duration, 0, 1))), map(percent => [initialTop + deltaTop * percent, initialLeft + deltaLeft * percent]), takeUntil(timer(duration)), endWith([scrollTop, scrollLeft]));\n      return observable.pipe(tap(([scrollTop, scrollLeft]) => {\n        var _a;\n        (_a = elementOrWindow.scrollTo) === null || _a === void 0 ? void 0 : _a.call(elementOrWindow, scrollLeft, scrollTop);\n      }));\n    }\n  }\n  TuiScrollService.ɵfac = function TuiScrollService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiScrollService)(i0.ɵɵinject(PERFORMANCE), i0.ɵɵinject(ANIMATION_FRAME));\n  };\n  TuiScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiScrollService,\n    factory: TuiScrollService.ɵfac,\n    providedIn: 'root'\n  });\n  return TuiScrollService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiStaticRequestService = /*#__PURE__*/(() => {\n  class TuiStaticRequestService {\n    constructor(win, platformId) {\n      this.win = win;\n      this.platformId = platformId;\n      this.cache = new Map();\n    }\n    request(url) {\n      const cache = this.cache.get(url);\n      if (cache) {\n        return cache;\n      }\n      const response$ = 'AbortController' in this.win || isPlatformServer(this.platformId) ? fromFetch(url) :\n      /**\n       * Fallback for Firefox 55 and 56\n       * TODO: drop after browser support bump\n       */\n      defer(() => from(fetch(url)));\n      const piped = response$.pipe(switchMap(response => __awaiter(this, void 0, void 0, function* () {\n        if (response.ok) {\n          return response.text();\n        }\n        throw new Error(`Failed to load ${url} (${response.statusText})`);\n      })), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      this.cache.set(url, piped);\n      return piped;\n    }\n  }\n  TuiStaticRequestService.ɵfac = function TuiStaticRequestService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiStaticRequestService)(i0.ɵɵinject(WINDOW), i0.ɵɵinject(PLATFORM_ID));\n  };\n  TuiStaticRequestService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiStaticRequestService,\n    factory: TuiStaticRequestService.ɵfac,\n    providedIn: 'root'\n  });\n  return TuiStaticRequestService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiSwipeService = /*#__PURE__*/(() => {\n  class TuiSwipeService extends Observable {\n    constructor({\n      nativeElement\n    }, {\n      timeout,\n      threshold\n    }, doc) {\n      super(subscriber => {\n        merge(tuiTypedFromEvent(nativeElement, 'touchstart', {\n          passive: true\n        }), tuiTypedFromEvent(doc, 'touchend')).pipe(pairwise(), filter(([first, second]) => !!first.touches.length && first.touches[0].identifier === second.changedTouches[0].identifier), map(([start, end]) => {\n          const startX = start.touches[0].clientX;\n          const startY = start.touches[0].clientY;\n          const endX = end.changedTouches[0].clientX;\n          const endY = end.changedTouches[0].clientY;\n          const distanceX = startX - endX;\n          const distanceY = startY - endY;\n          const duration = end.timeStamp - start.timeStamp;\n          if ((Math.abs(distanceX) > threshold || Math.abs(distanceY) > threshold) && duration < timeout) {\n            return {\n              direction: tuiGetSwipeDirection(distanceX, distanceY),\n              events: [start, end]\n            };\n          }\n          return null;\n        }), filter(tuiIsPresent)).subscribe(subscriber);\n      });\n    }\n  }\n  TuiSwipeService.ɵfac = function TuiSwipeService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiSwipeService)(i0.ɵɵinject(ElementRef), i0.ɵɵinject(TUI_SWIPE_OPTIONS), i0.ɵɵinject(DOCUMENT));\n  };\n  TuiSwipeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiSwipeService,\n    factory: TuiSwipeService.ɵfac\n  });\n  return TuiSwipeService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TOUCH_SENSITIVITY = 0.01;\nlet TuiZoomService = /*#__PURE__*/(() => {\n  class TuiZoomService extends Observable {\n    constructor({\n      nativeElement\n    }, {\n      wheelSensitivity\n    }) {\n      super(subscriber => {\n        merge(tuiTypedFromEvent(nativeElement, 'touchstart', {\n          passive: true\n        }).pipe(filter(({\n          touches\n        }) => touches.length > 1), switchMap(startEvent => tuiTypedFromEvent(nativeElement, 'touchmove', {\n          passive: true\n        }).pipe(tuiPreventDefault(), scan((prev, event) => {\n          const distance = tuiDistanceBetweenTouches(event);\n          return {\n            event,\n            distance,\n            delta: (distance - prev.distance) * TOUCH_SENSITIVITY\n          };\n        }, {\n          event: startEvent,\n          distance: tuiDistanceBetweenTouches(startEvent),\n          delta: 0\n        }), map(({\n          event,\n          delta\n        }) => {\n          const clientX = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n          const clientY = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n          return {\n            clientX,\n            clientY,\n            delta,\n            event\n          };\n        }), takeUntil(tuiTypedFromEvent(nativeElement, 'touchend'))))), tuiTypedFromEvent(nativeElement, 'wheel', {\n          passive: false\n        }).pipe(tuiPreventDefault(), map(wheel => ({\n          clientX: wheel.clientX,\n          clientY: wheel.clientY,\n          delta: -wheel.deltaY * wheelSensitivity,\n          event: wheel\n        })))).subscribe(subscriber);\n      });\n    }\n  }\n  TuiZoomService.ɵfac = function TuiZoomService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiZoomService)(i0.ɵɵinject(ElementRef), i0.ɵɵinject(TUI_ZOOM_OPTIONS));\n  };\n  TuiZoomService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TuiZoomService,\n    factory: TuiZoomService.ɵfac\n  });\n  return TuiZoomService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiDestroyService, TuiDirectiveStylesService, TuiFocusVisibleService, TuiIdService, TuiObscuredService, TuiPanService, TuiParentsScrollService, TuiResizeService, TuiScrollService, TuiStaticRequestService, TuiSwipeService, TuiZoomService };\n//# sourceMappingURL=taiga-ui-cdk-services.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}