{"ast":null,"code":"import { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { TuiPureException } from '@taiga-ui/cdk/exceptions';\n\n/**\n * @deprecated:\n * not compatible with TypeScript 5\n */\nfunction tuiDebounce(timeout) {\n  let timeoutRef;\n  return function (_target, _key, descriptor) {\n    const {\n      value\n    } = descriptor;\n    descriptor.value = function (...args) {\n      clearTimeout(timeoutRef);\n      timeoutRef = setTimeout(() => value.apply(this, args), timeout);\n    };\n    return descriptor;\n  };\n}\nfunction errorGetDefault(key, component) {\n  return `Default value for ${String(key)} was not provided in ${component}, error in Taiga UI Angular Kit`;\n}\nfunction errorSetDefault(key, component) {\n  return `Undefined was passed as ${String(key)} to ${component}, which is invalid input, using default value:`;\n}\nfunction errorSetDefaultInitial(key, component) {\n  return `Undefined was passed as default value for ${String(key)} to ${component}, error in Taiga UI Angular Kit`;\n}\n/**\n * @deprecated:\n * not compatible with TypeScript 5\n *\n * Decorator for checking input values for undefined. You can also pass\n * optional assertion to check input against.\n *\n * CAUTION: This decorator overwrites other getters and setters.\n */\nfunction tuiDefaultProp(assertion, ...args) {\n  return (target, key) => {\n    const {\n      name\n    } = target.constructor;\n    const errorGetDefaultMessage = ngDevMode && errorGetDefault(key, name);\n    const errorSetDefaultMessage = ngDevMode && errorSetDefault(key, name);\n    Object.defineProperty(target, key, {\n      configurable: true,\n      get() {\n        ngDevMode && tuiAssert.assert(false, errorGetDefaultMessage);\n        return undefined;\n      },\n      set(initialValue) {\n        const isValid = initialValue !== undefined;\n        const errorMessage = ngDevMode && errorSetDefaultInitial(key, name);\n        let currentValue = initialValue;\n        ngDevMode && tuiAssert.assert(isValid, errorMessage);\n        if (ngDevMode && isValid && assertion && tuiAssert) {\n          tuiAssert.assert(assertion.call(this, initialValue), `${String(key)} in ${name} received:`, initialValue, ...args);\n        }\n        Object.defineProperty(this, key, {\n          configurable: true,\n          get() {\n            return currentValue;\n          },\n          set(value) {\n            const isValid = value !== undefined;\n            const backupValue = initialValue;\n            ngDevMode && tuiAssert.assert(isValid, errorSetDefaultMessage, String(backupValue));\n            if (ngDevMode && isValid && assertion && tuiAssert) {\n              tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n            }\n            currentValue = isValid ? value : backupValue;\n          }\n        });\n      }\n    });\n  };\n}\nfunction decorateMethod(originalMethod) {\n  let previousArgs = [];\n  let originalFnWasCalledLeastAtOnce = false;\n  let pureValue;\n  return function tuiPureMethodPatched(...args) {\n    const isPure = originalFnWasCalledLeastAtOnce && previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index]);\n    if (isPure) {\n      return pureValue;\n    }\n    previousArgs = args;\n    pureValue = originalMethod.apply(this, args);\n    originalFnWasCalledLeastAtOnce = true;\n    return pureValue;\n  };\n}\nfunction decorateGetter(originalGetter, propertyKey, enumerable = true) {\n  return function tuiPureGetterPatched() {\n    const value = originalGetter.call(this);\n    Object.defineProperty(this, propertyKey, {\n      enumerable,\n      value\n    });\n    return value;\n  };\n}\nfunction tuiPure(target, propertyKeyOrContext, descriptor) {\n  if (typeof target === 'function') {\n    const context = propertyKeyOrContext;\n    if (context.kind === 'getter') {\n      return decorateGetter(target, context.name);\n    }\n    if (context.kind === 'method') {\n      return decorateMethod(target);\n    }\n    throw new TuiPureException();\n  }\n  const {\n    get,\n    enumerable,\n    value\n  } = descriptor;\n  const propertyKey = propertyKeyOrContext;\n  if (get) {\n    return {\n      configurable: true,\n      enumerable,\n      get: decorateGetter(get, propertyKey, enumerable)\n    };\n  }\n  if (typeof value !== 'function') {\n    throw new TuiPureException();\n  }\n  const original = value;\n  return {\n    configurable: true,\n    enumerable,\n    get() {\n      let previousArgs = [];\n      let originalFnWasCalledLeastAtOnce = false;\n      let pureValue;\n      const patched = (...args) => {\n        const isPure = originalFnWasCalledLeastAtOnce && previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index]);\n        if (isPure) {\n          return pureValue;\n        }\n        previousArgs = args;\n        pureValue = original.apply(this, args);\n        originalFnWasCalledLeastAtOnce = true;\n        return pureValue;\n      };\n      Object.defineProperty(this, propertyKey, {\n        configurable: true,\n        value: patched\n      });\n      return patched;\n    }\n  };\n}\nfunction errorSet(key, component) {\n  return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;\n}\n/**\n * @deprecated:\n * not compatible with TypeScript 5\n *\n * Decorator for checking input setter values against a custom assertion which\n * takes value passed to input setter and component instance as arguments.\n * It specifically checks for undefined values and prevents calls to the\n * original setter in this case.\n */\nfunction tuiRequiredSetter(assertion, ...args) {\n  return (target, key, {\n    configurable,\n    enumerable,\n    get,\n    set\n  }) => {\n    const {\n      name\n    } = target.constructor;\n    return {\n      configurable,\n      enumerable,\n      get,\n      set(value) {\n        if (ngDevMode && value !== undefined && assertion && tuiAssert) {\n          tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n        }\n        if (!set || value === undefined) {\n          ngDevMode && tuiAssert.assert(value !== undefined, errorSet(key, name));\n          return;\n        }\n        set.call(this, value);\n      }\n    };\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiDebounce, tuiDefaultProp, tuiPure, tuiRequiredSetter };\n//# sourceMappingURL=taiga-ui-cdk-decorators.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}