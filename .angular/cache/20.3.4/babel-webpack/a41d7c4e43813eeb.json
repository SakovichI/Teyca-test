{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { ElementRef, Directive, NgZone, Renderer2, Inject, Self, Input, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport { ANIMATION_FRAME } from '@ng-web-apis/common';\nimport { tuiTypedFromEvent, tuiStopPropagation, tuiZonefree, POLLING_TIME, tuiScrollFrom, TuiDestroyService, TUI_SCROLL_REF, tuiZoneOptimized, TuiLetModule } from '@taiga-ui/cdk';\nimport { tuiFadeIn } from '@taiga-ui/core/animations';\nimport { MODE_PROVIDER } from '@taiga-ui/core/providers';\nimport { TUI_ELEMENT_REF, TUI_ANIMATION_OPTIONS, TUI_MODE } from '@taiga-ui/core/tokens';\nimport { map, switchMap, takeUntil, throttleTime, startWith, distinctUntilChanged } from 'rxjs/operators';\nimport * as i1$1 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i1 from 'rxjs';\nimport { merge } from 'rxjs';\nfunction TuiScrollControlsComponent_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵelement(1, \"div\", 4);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const bars_r1 = i0.ɵɵnextContext().ngIf;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"t-bar_has-horizontal\", bars_r1[1]);\n    i0.ɵɵproperty(\"@tuiFadeIn\", ctx_r1.animation);\n  }\n}\nfunction TuiScrollControlsComponent_ng_container_0_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelement(1, \"div\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const bars_r1 = i0.ɵɵnextContext().ngIf;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"t-bar_has-vertical\", bars_r1[0]);\n    i0.ɵɵproperty(\"@tuiFadeIn\", ctx_r1.animation);\n  }\n}\nfunction TuiScrollControlsComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TuiScrollControlsComponent_ng_container_0_div_1_Template, 2, 3, \"div\", 1)(2, TuiScrollControlsComponent_ng_container_0_div_2_Template, 2, 3, \"div\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const bars_r1 = ctx.ngIf;\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", bars_r1[0]);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", bars_r1[1]);\n  }\n}\nlet TuiScrollbarWrapperDirective = /*#__PURE__*/(() => {\n  class TuiScrollbarWrapperDirective {}\n  TuiScrollbarWrapperDirective.ɵfac = function TuiScrollbarWrapperDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiScrollbarWrapperDirective)();\n  };\n  TuiScrollbarWrapperDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiScrollbarWrapperDirective,\n    selectors: [[\"\", \"tuiScrollbarWrapper\", \"\"]],\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TUI_ELEMENT_REF,\n      useExisting: ElementRef\n    }])]\n  });\n  return TuiScrollbarWrapperDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MIN_WIDTH = 24;\nfunction getOffsetVertical({\n  clientY\n}, {\n  top,\n  height\n}) {\n  return (clientY - top) / height;\n}\nfunction getOffsetHorizontal({\n  clientX\n}, {\n  left,\n  width\n}) {\n  return (clientX - left) / width;\n}\nlet TuiScrollbarDirective = /*#__PURE__*/(() => {\n  class TuiScrollbarDirective {\n    constructor(zone, renderer, destroy$, animationFrame$, wrapper, container, doc, el) {\n      this.wrapper = wrapper;\n      this.container = container;\n      this.doc = doc;\n      this.el = el;\n      this.tuiScrollbar = 'vertical';\n      const {\n        nativeElement\n      } = this.el;\n      const mousedown$ = tuiTypedFromEvent(nativeElement, 'mousedown');\n      const mousemove$ = tuiTypedFromEvent(this.doc, 'mousemove');\n      const mouseup$ = tuiTypedFromEvent(this.doc, 'mouseup');\n      const mousedownWrapper$ = tuiTypedFromEvent(this.wrapper.nativeElement, 'mousedown');\n      merge(mousedownWrapper$.pipe(map(event => this.getScrolled(event, 0.5, 0.5))), mousedown$.pipe(tuiStopPropagation(), switchMap(event => {\n        const rect = nativeElement.getBoundingClientRect();\n        const vertical = getOffsetVertical(event, rect);\n        const horizontal = getOffsetHorizontal(event, rect);\n        return mousemove$.pipe(map(event => this.getScrolled(event, vertical, horizontal)), takeUntil(mouseup$));\n      }))).pipe(tuiZonefree(zone), takeUntil(destroy$)).subscribe(([scrollTop, scrollLeft]) => {\n        if (this.tuiScrollbar === 'vertical') {\n          renderer.setProperty(this.element, 'scrollTop', scrollTop);\n        } else {\n          renderer.setProperty(this.element, 'scrollLeft', scrollLeft);\n        }\n      });\n      merge(animationFrame$.pipe(throttleTime(POLLING_TIME)), tuiScrollFrom(this.element)).pipe(tuiZonefree(zone), takeUntil(destroy$)).subscribe(() => {\n        if (this.tuiScrollbar === 'vertical') {\n          renderer.setStyle(nativeElement, 'top', `${this.thumb * 100}%`);\n          renderer.setStyle(nativeElement, 'height', `${this.view * 100}%`);\n        } else {\n          renderer.setStyle(nativeElement, 'left', `${this.thumb * 100}%`);\n          renderer.setStyle(nativeElement, 'width', `${this.view * 100}%`);\n        }\n      });\n    }\n    get scrolled() {\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n        scrollLeft,\n        scrollWidth,\n        clientWidth\n      } = this.element;\n      return this.tuiScrollbar === 'vertical' ? scrollTop / (scrollHeight - clientHeight) : scrollLeft / (scrollWidth - clientWidth);\n    }\n    get compensation() {\n      const {\n        clientHeight,\n        scrollHeight,\n        clientWidth,\n        scrollWidth\n      } = this.element;\n      if (clientHeight * clientHeight / scrollHeight > MIN_WIDTH && this.tuiScrollbar === 'vertical' || clientWidth * clientWidth / scrollWidth > MIN_WIDTH && this.tuiScrollbar === 'horizontal') {\n        return 0;\n      }\n      return this.tuiScrollbar === 'vertical' ? MIN_WIDTH / clientHeight : MIN_WIDTH / clientWidth;\n    }\n    get thumb() {\n      const compensation = this.compensation || this.view;\n      return this.scrolled * (1 - compensation);\n    }\n    get view() {\n      const {\n        clientHeight,\n        scrollHeight,\n        clientWidth,\n        scrollWidth\n      } = this.element;\n      return this.tuiScrollbar === 'vertical' ? Math.ceil(clientHeight / scrollHeight * 100) / 100 : Math.ceil(clientWidth / scrollWidth * 100) / 100;\n    }\n    get element() {\n      return this.container.nativeElement;\n    }\n    getScrolled({\n      clientY,\n      clientX\n    }, offsetVertical, offsetHorizontal) {\n      const {\n        offsetHeight,\n        offsetWidth\n      } = this.el.nativeElement;\n      const {\n        top,\n        left,\n        width,\n        height\n      } = this.wrapper.nativeElement.getBoundingClientRect();\n      const maxTop = this.element.scrollHeight - height;\n      const maxLeft = this.element.scrollWidth - width;\n      const scrolledTop = (clientY - top - offsetHeight * offsetVertical) / (height - offsetHeight);\n      const scrolledLeft = (clientX - left - offsetWidth * offsetHorizontal) / (width - offsetWidth);\n      return [maxTop * scrolledTop, maxLeft * scrolledLeft];\n    }\n  }\n  TuiScrollbarDirective.ɵfac = function TuiScrollbarDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiScrollbarDirective)(i0.ɵɵdirectiveInject(NgZone), i0.ɵɵdirectiveInject(Renderer2), i0.ɵɵdirectiveInject(TuiDestroyService, 2), i0.ɵɵdirectiveInject(ANIMATION_FRAME), i0.ɵɵdirectiveInject(TUI_ELEMENT_REF), i0.ɵɵdirectiveInject(TUI_SCROLL_REF), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(ElementRef));\n  };\n  TuiScrollbarDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiScrollbarDirective,\n    selectors: [[\"\", \"tuiScrollbar\", \"\"]],\n    inputs: {\n      tuiScrollbar: \"tuiScrollbar\"\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([TuiDestroyService])]\n  });\n  return TuiScrollbarDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiScrollControlsComponent = /*#__PURE__*/(() => {\n  class TuiScrollControlsComponent {\n    constructor(animation, zone, scrollRef, animationFrame$, mode$) {\n      this.animation = animation;\n      this.zone = zone;\n      this.scrollRef = scrollRef;\n      this.animationFrame$ = animationFrame$;\n      this.mode$ = mode$;\n      this.refresh$ = this.animationFrame$.pipe(throttleTime(300), map(() => this.scrollbars), startWith([false, false]), distinctUntilChanged((a, b) => a[0] === b[0] && a[1] === b[1]), tuiZoneOptimized(this.zone));\n    }\n    get scrollbars() {\n      const {\n        clientHeight,\n        scrollHeight,\n        clientWidth,\n        scrollWidth\n      } = this.scrollRef.nativeElement;\n      return [Math.ceil(clientHeight / scrollHeight * 100) < 100, Math.ceil(clientWidth / scrollWidth * 100) < 100];\n    }\n  }\n  TuiScrollControlsComponent.ɵfac = function TuiScrollControlsComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiScrollControlsComponent)(i0.ɵɵdirectiveInject(TUI_ANIMATION_OPTIONS), i0.ɵɵdirectiveInject(NgZone), i0.ɵɵdirectiveInject(TUI_SCROLL_REF), i0.ɵɵdirectiveInject(ANIMATION_FRAME), i0.ɵɵdirectiveInject(TUI_MODE));\n  };\n  TuiScrollControlsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TuiScrollControlsComponent,\n    selectors: [[\"tui-scroll-controls\"]],\n    hostBindings: function TuiScrollControlsComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"$.data-mode.attr\", function TuiScrollControlsComponent___data_mode_attr_HostBindingHandler() {\n          return ctx.mode$;\n        });\n      }\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([MODE_PROVIDER])],\n    decls: 2,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [\"tuiScrollbarWrapper\", \"\", \"class\", \"t-bar t-bar_vertical\", 3, \"t-bar_has-horizontal\", 4, \"ngIf\"], [\"tuiScrollbarWrapper\", \"\", \"class\", \"t-bar t-bar_horizontal\", 3, \"t-bar_has-vertical\", 4, \"ngIf\"], [\"tuiScrollbarWrapper\", \"\", 1, \"t-bar\", \"t-bar_vertical\"], [\"tuiScrollbar\", \"vertical\", 1, \"t-thumb\"], [\"tuiScrollbarWrapper\", \"\", 1, \"t-bar\", \"t-bar_horizontal\"], [\"tuiScrollbar\", \"horizontal\", 1, \"t-thumb\"]],\n    template: function TuiScrollControlsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, TuiScrollControlsComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n        i0.ɵɵpipe(1, \"async\");\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(1, 1, ctx.refresh$));\n      }\n    },\n    dependencies: [i1$1.NgIf, TuiScrollbarWrapperDirective, TuiScrollbarDirective, i1$1.AsyncPipe],\n    styles: [\"[_nghost-%COMP%]{position:-webkit-sticky;position:sticky;top:0;left:0;z-index:1;min-width:calc(100% - 1px);min-height:calc(100% - 1px);max-width:calc(100% - 1px);max-height:calc(100% - 1px);float:left;-webkit-margin-end:calc(-100% + 1px);margin-inline-end:calc(-100% + 1px);pointer-events:none}.t-bar[_ngcontent-%COMP%]{position:absolute;right:0;bottom:0;pointer-events:auto}.t-bar_vertical[_ngcontent-%COMP%]{top:0;width:.875rem}.t-bar_horizontal[_ngcontent-%COMP%]{left:0;height:.875rem}.t-bar_has-horizontal[_ngcontent-%COMP%]{bottom:.5rem}.t-bar_has-vertical[_ngcontent-%COMP%]{right:.5rem}.t-thumb[_ngcontent-%COMP%]{transition-property:all;transition-duration:.15s;transition-timing-function:ease-in-out;position:absolute;border-radius:6.25rem;border:.25rem solid transparent;cursor:pointer;pointer-events:auto;-webkit-user-select:none;-moz-user-select:none;user-select:none;background:var(--tui-text-01);background-clip:content-box;box-sizing:border-box;transition-property:width,height;opacity:.2}.t-thumb[_ngcontent-%COMP%]:hover{opacity:.24}.t-thumb[_ngcontent-%COMP%]:active{opacity:.48}[data-mode=onDark][_nghost-%COMP%]   .t-thumb[_ngcontent-%COMP%]{background-color:var(--tui-text-01-night)}.t-bar_vertical[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]{right:0;width:.75rem;min-height:1.25rem}.t-bar_vertical[_ngcontent-%COMP%]:hover   .t-thumb[_ngcontent-%COMP%], .t-bar_vertical[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]:active{width:.875rem}.t-bar_horizontal[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]{bottom:0;height:.75rem;min-width:1.25rem}.t-bar_horizontal[_ngcontent-%COMP%]:hover   .t-thumb[_ngcontent-%COMP%], .t-bar_horizontal[_ngcontent-%COMP%]   .t-thumb[_ngcontent-%COMP%]:active{height:.875rem}\"],\n    data: {\n      animation: [tuiFadeIn]\n    },\n    changeDetection: 0\n  });\n  return TuiScrollControlsComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** @deprecated import from `@taiga-ui/cdk` instead */\nlet TuiScrollControlsModule = /*#__PURE__*/(() => {\n  class TuiScrollControlsModule {}\n  TuiScrollControlsModule.ɵfac = function TuiScrollControlsModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiScrollControlsModule)();\n  };\n  TuiScrollControlsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TuiScrollControlsModule\n  });\n  TuiScrollControlsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, TuiLetModule]]\n  });\n  return TuiScrollControlsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiScrollControlsComponent, TuiScrollControlsModule, TuiScrollbarDirective };\n//# sourceMappingURL=taiga-ui-core-components-scroll-controls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}