{"ast":null,"code":"import { tuiClamp } from '@taiga-ui/cdk/utils/math';\nimport { tuiIsPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\nfunction canScrollVertical(element, rootElement, scrollEnd) {\n  let currentElement = element;\n  while (currentElement !== rootElement.parentElement) {\n    if (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd || Math.ceil(currentElement.scrollTop + currentElement.clientHeight) < currentElement.scrollHeight && scrollEnd) {\n      return true;\n    }\n    if (currentElement.parentElement) {\n      currentElement = currentElement.parentElement;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nfunction canScrollHorizontal(element, rootElement, scrollEnd) {\n  let currentElement = element;\n  while (currentElement !== rootElement.parentElement) {\n    if (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd || Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) < currentElement.scrollWidth && scrollEnd) {\n      return true;\n    }\n    if (currentElement.parentElement) {\n      currentElement = currentElement.parentElement;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nfunction tuiCanScroll(element, rootElement, vertical, scrollEnd) {\n  return vertical ? canScrollVertical(element, rootElement, scrollEnd) : canScrollHorizontal(element, rootElement, scrollEnd);\n}\nfunction tuiContainsOrAfter(current, node) {\n  try {\n    return current.contains(node) || !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING);\n  } catch (_a) {\n    return false;\n  }\n}\nfunction tuiIsInput(element) {\n  return element.matches('input');\n}\nfunction tuiIsTextarea(element) {\n  return element.matches('textarea');\n}\nfunction tuiIsTextfield(element) {\n  return tuiIsInput(element) || tuiIsTextarea(element);\n}\nfunction tuiIsElement(node) {\n  return !!node && 'nodeType' in node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction tuiIsHTMLElement(node) {\n  return !!node && node instanceof node.ownerDocument.defaultView.HTMLElement;\n}\nfunction tuiIsTextNode(node) {\n  return node.nodeType === Node.TEXT_NODE;\n}\n\n/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nfunction tuiGetActualTarget(event) {\n  return event.composedPath()[0];\n}\nconst DEFAULT_FORMAT = 'text/plain';\n/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nfunction tuiGetClipboardDataText(event, format = DEFAULT_FORMAT) {\n  return 'clipboardData' in event && event.clipboardData !== null ? event.clipboardData.getData(format) || event.clipboardData.getData(DEFAULT_FORMAT) : event.target.ownerDocument.defaultView.clipboardData.getData('text');\n}\nfunction tuiGetDocumentOrShadowRoot(node) {\n  return 'getRootNode' in node && node.isConnected ? node.getRootNode() : node.ownerDocument;\n}\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n * TODO: v4.0 change function signature to\n * ```ts\n * function tuiGetElementObscures(element: Element): readonly [Element, Element, Element, Element] | [] | null\n * ```\n */\nfunction tuiGetElementObscures(element) {\n  const {\n    ownerDocument\n  } = element;\n  if (!(ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.defaultView) || !element.getBoundingClientRect) {\n    return null;\n  }\n  const {\n    innerWidth,\n    innerHeight\n  } = ownerDocument.defaultView;\n  const doc = tuiGetDocumentOrShadowRoot(element);\n  const rect = element.getBoundingClientRect();\n  if (rect.width === 0 && rect.height === 0) {\n    return null;\n  }\n  const left = tuiClamp(Math.round(rect.left) + 2, 0, innerWidth);\n  const top = tuiClamp(Math.round(rect.top) + 2, 0, innerHeight);\n  const right = tuiClamp(Math.round(rect.right) - 2, 0, innerWidth);\n  const bottom = tuiClamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n  const horizontalMiddle = tuiClamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n  const verticalMiddle = tuiClamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n  const elements = [doc.elementFromPoint(horizontalMiddle, top), doc.elementFromPoint(horizontalMiddle, bottom), doc.elementFromPoint(left, verticalMiddle), doc.elementFromPoint(right, verticalMiddle)];\n  const nonNull = elements.filter(tuiIsPresent);\n  if (!nonNull.length) {\n    return nonNull;\n  }\n  const filtered = nonNull.filter(el => !element.contains(el) && !el.contains(element));\n  return filtered.length === 4 ? filtered : null;\n}\n\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nfunction tuiGetElementOffset(host, element) {\n  ngDevMode && tuiAssert.assert(host.contains(element), 'Host must contain element');\n  let {\n    offsetTop,\n    offsetLeft,\n    offsetParent\n  } = element;\n  while (tuiIsHTMLElement(offsetParent) && offsetParent !== host) {\n    offsetTop += offsetParent.offsetTop;\n    offsetLeft += offsetParent.offsetLeft;\n    offsetParent = offsetParent.offsetParent;\n  }\n  return {\n    offsetTop,\n    offsetLeft\n  };\n}\n\n/**\n * Finds the nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\nfunction tuiGetScrollParent(element, vertical = true) {\n  if (element === null) {\n    return null;\n  }\n  if (vertical && element.scrollHeight > element.clientHeight) {\n    return element;\n  }\n  if (!vertical && element.scrollWidth > element.clientWidth) {\n    return element;\n  }\n  return tuiGetScrollParent(element.parentElement, vertical);\n}\n\n/**\n * @description:\n * cross browser way to get selected text\n *\n * History:\n * BUG - window.getSelection() fails when text selected in a form field\n * https://bugzilla.mozilla.org/show_bug.cgi?id=85686\n */\nfunction tuiGetSelectedText({\n  getSelection,\n  document\n}) {\n  var _a;\n  return document.activeElement && tuiIsTextfield(document.activeElement) ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0) : ((_a = getSelection()) === null || _a === void 0 ? void 0 : _a.toString()) || null;\n}\nfunction tuiIsCurrentTarget({\n  target,\n  currentTarget\n}) {\n  return target === currentTarget;\n}\nfunction tuiIsElementEditable(element) {\n  return tuiIsTextfield(element) && !element.readOnly || !!element.isContentEditable;\n}\n\n/**\n * Checks if an app is running inside <iframe /> tag\n */\nfunction tuiIsInsideIframe(win) {\n  return win.parent !== win;\n}\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nfunction tuiIsNodeIn(node, selector) {\n  var _a;\n  return tuiIsTextNode(node) ? !!((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.closest(selector)) : tuiIsElement(node) && !!node.closest(selector);\n}\nfunction tuiPointToClientRect(x = 0, y = 0) {\n  const rect = {\n    x,\n    y,\n    left: x,\n    right: x,\n    top: y,\n    bottom: y,\n    width: 0,\n    height: 0\n  };\n  return Object.assign(Object.assign({}, rect), {\n    toJSON() {\n      return rect;\n    }\n  });\n}\nfunction tuiRetargetedBoundaryCrossing(event) {\n  // firefox\n  if ('explicitOriginalTarget' in event) {\n    return (event === null || event === void 0 ? void 0 : event.explicitOriginalTarget) !== event.target;\n  }\n  // chrome\n  if ('pointerId' in event) {\n    return event.pointerId === -1;\n  }\n  // safari\n  if ('detail' in event && 'webkitForce' in event) {\n    return (event === null || event === void 0 ? void 0 : event.detail) === 0;\n  }\n  return false;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCanScroll, tuiContainsOrAfter, tuiGetActualTarget, tuiGetClipboardDataText, tuiGetDocumentOrShadowRoot, tuiGetElementObscures, tuiGetElementOffset, tuiGetScrollParent, tuiGetSelectedText, tuiIsCurrentTarget, tuiIsElement, tuiIsElementEditable, tuiIsHTMLElement, tuiIsInput, tuiIsInsideIframe, tuiIsNodeIn, tuiIsTextNode, tuiIsTextarea, tuiIsTextfield, tuiPointToClientRect, tuiRetargetedBoundaryCrossing };\n//# sourceMappingURL=taiga-ui-cdk-utils-dom.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}