{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, ElementRef, Optional, Self, Inject, Renderer2, NgZone, InjectionToken, Input, NgModule } from '@angular/core';\nimport { tuiCoerceBooleanProperty } from '@taiga-ui/cdk/coercion';\nimport * as i1$1 from '@taiga-ui/cdk/services';\nimport { TuiDestroyService } from '@taiga-ui/cdk/services';\nimport * as i1 from 'rxjs';\nimport { race, timer } from 'rxjs';\nimport { throttleTime, map, skipWhile, take, takeUntil } from 'rxjs/operators';\nimport { ANIMATION_FRAME, WINDOW } from '@ng-web-apis/common';\nimport { TUI_FOCUSABLE_ITEM_ACCESSOR, TUI_IS_IOS } from '@taiga-ui/cdk/tokens';\nimport { tuiCreateToken, tuiProvideOptions } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { POLLING_TIME } from '@taiga-ui/cdk/constants';\nimport { tuiPx, tuiIsPresent } from '@taiga-ui/cdk/utils';\nlet AbstractTuiAutofocusHandler = /*#__PURE__*/(() => {\n  class AbstractTuiAutofocusHandler {\n    constructor(focusable, el) {\n      this.focusable = focusable;\n      this.el = el;\n    }\n    get element() {\n      var _a;\n      return ((_a = this.focusable) === null || _a === void 0 ? void 0 : _a.nativeFocusableElement) || this.el.nativeElement;\n    }\n    get isTextFieldElement() {\n      return this.element.matches('input, textarea, [contenteditable]');\n    }\n  }\n  AbstractTuiAutofocusHandler.ɵfac = function AbstractTuiAutofocusHandler_Factory(__ngFactoryType__) {\n    i0.ɵɵinvalidFactory();\n  };\n  AbstractTuiAutofocusHandler.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractTuiAutofocusHandler,\n    standalone: false\n  });\n  return AbstractTuiAutofocusHandler;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TIMEOUT = 1000;\nconst NG_ANIMATION_SELECTOR = '.ng-animating';\nlet TuiDefaultAutofocusHandler = /*#__PURE__*/(() => {\n  class TuiDefaultAutofocusHandler extends AbstractTuiAutofocusHandler {\n    constructor(focusable, el, animationFrame$) {\n      super(focusable, el);\n      this.animationFrame$ = animationFrame$;\n    }\n    setFocus() {\n      if (this.isTextFieldElement) {\n        race(timer(TIMEOUT), this.animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => this.element.closest(NG_ANIMATION_SELECTOR)), skipWhile(Boolean), take(1))).subscribe(() => this.element.focus({\n          preventScroll: true\n        }));\n      } else {\n        this.element.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }\n  TuiDefaultAutofocusHandler.ɵfac = function TuiDefaultAutofocusHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDefaultAutofocusHandler)(i0.ɵɵdirectiveInject(TUI_FOCUSABLE_ITEM_ACCESSOR, 10), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(ANIMATION_FRAME));\n  };\n  TuiDefaultAutofocusHandler.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDefaultAutofocusHandler,\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiDefaultAutofocusHandler;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TEXTFIELD_ATTRS = ['type', 'inputMode', 'autocomplete', 'accept', 'min', 'max', 'step', 'pattern', 'size', 'maxlength'];\nlet TuiIosAutofocusHandler = /*#__PURE__*/(() => {\n  class TuiIosAutofocusHandler extends AbstractTuiAutofocusHandler {\n    constructor(focusable, el, renderer, zone, win) {\n      super(focusable, el);\n      this.renderer = renderer;\n      this.zone = zone;\n      this.win = win;\n      this.patchCssStyles();\n    }\n    setFocus() {\n      if (this.isTextFieldElement) {\n        this.zone.runOutsideAngular(() => this.iosWebkitAutofocus());\n      } else {\n        this.element.focus({\n          preventScroll: true\n        });\n      }\n    }\n    iosWebkitAutofocus() {\n      var _a;\n      const fakeInput = this.makeFakeInput();\n      const duration = this.getDurationTimeBeforeFocus();\n      let fakeFocusTimeoutId = 0;\n      let elementFocusTimeoutId = 0;\n      const blurHandler = () => fakeInput.focus({\n        preventScroll: true\n      });\n      const focusHandler = () => {\n        clearTimeout(fakeFocusTimeoutId);\n        fakeFocusTimeoutId = this.win.setTimeout(() => {\n          clearTimeout(elementFocusTimeoutId);\n          fakeInput.removeEventListener('blur', blurHandler);\n          fakeInput.removeEventListener('focus', focusHandler);\n          elementFocusTimeoutId = this.win.setTimeout(() => {\n            this.element.focus({\n              preventScroll: false\n            });\n            fakeInput.remove();\n          }, duration);\n        });\n      };\n      fakeInput.addEventListener('blur', blurHandler, {\n        once: true\n      });\n      fakeInput.addEventListener('focus', focusHandler);\n      if (this.insideDialog()) {\n        this.win.document.body.appendChild(fakeInput);\n      } else {\n        (_a = this.element.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(fakeInput);\n      }\n      fakeInput.focus({\n        preventScroll: true\n      });\n    }\n    /**\n     * @note:\n     * emulate textfield position in layout with cursor\n     * before focus to real textfield element\n     *\n     * required note:\n     * [fakeInput.readOnly = true] ~\n     * don't use {readOnly: true} value, it's doesn't work for emulate autofill\n     *\n     * [fakeInput.style.opacity = 0] ~\n     * don't use {opacity: 0}, sometimes it's doesn't work for emulate real input\n     *\n     * [fakeInput.style.fontSize = 16px] ~\n     * disable possible auto zoom\n     *\n     * [fakeInput.style.top/left] ~\n     * emulate position cursor before focus to real textfield element\n     */\n    makeFakeInput() {\n      const fakeInput = this.renderer.createElement('input');\n      const rect = this.element.getBoundingClientRect();\n      this.patchFakeInputFromFocusableElement(fakeInput);\n      fakeInput.style.height = tuiPx(rect.height);\n      fakeInput.style.width = tuiPx(rect.width / 2);\n      fakeInput.style.position = 'fixed';\n      fakeInput.style.zIndex = '-99999999';\n      fakeInput.style.caretColor = 'transparent';\n      fakeInput.style.border = 'none';\n      fakeInput.style.outline = 'none';\n      fakeInput.style.color = 'transparent';\n      fakeInput.style.background = 'transparent';\n      fakeInput.style.cursor = 'none';\n      fakeInput.style.fontSize = tuiPx(16);\n      fakeInput.style.top = tuiPx(rect.top);\n      fakeInput.style.left = tuiPx(rect.left);\n      return fakeInput;\n    }\n    getDurationTimeBeforeFocus() {\n      return parseFloat(this.win.getComputedStyle(this.element).getPropertyValue('--tui-duration')) || 0;\n    }\n    /**\n     * @note:\n     * unfortunately, in older versions of iOS\n     * there is a bug that the fake input cursor\n     * will move along with the dialog animation\n     * and then that dialog will be shaking\n     */\n    insideDialog() {\n      return !!this.element.closest('tui-dialog');\n    }\n    /**\n     * @note:\n     * This is necessary so that the viewport isn't recalculated\n     * and then the dialogs don't shake.\n     *\n     * Also, we need to fixed height viewport,\n     * so that when focusing the dialogs don't shake\n     */\n    patchCssStyles() {\n      [this.win.document.documentElement, this.win.document.body].forEach(element => {\n        element.style.setProperty('overflow', 'auto');\n        element.style.setProperty('height', '100%');\n      });\n    }\n    /**\n     * @note:\n     * inherit basic attributes values from real input\n     * for help iOS detect what do you want see on keyboard,\n     * for example [inputMode=numeric, autocomplete=cc-number]\n     */\n    patchFakeInputFromFocusableElement(fakeInput) {\n      TEXTFIELD_ATTRS.forEach(attr => {\n        const value = this.element.getAttribute(attr);\n        if (tuiIsPresent(value)) {\n          fakeInput.setAttribute(attr, value);\n        }\n      });\n    }\n  }\n  TuiIosAutofocusHandler.ɵfac = function TuiIosAutofocusHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiIosAutofocusHandler)(i0.ɵɵdirectiveInject(TUI_FOCUSABLE_ITEM_ACCESSOR, 10), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(Renderer2), i0.ɵɵdirectiveInject(NgZone), i0.ɵɵdirectiveInject(WINDOW));\n  };\n  TuiIosAutofocusHandler.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiIosAutofocusHandler,\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiIosAutofocusHandler;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TUI_AUTOFOCUS_DEFAULT_OPTIONS = {\n  delay: NaN // NaN = no delay/sync\n};\nconst TUI_AUTOFOCUS_OPTIONS = tuiCreateToken(TUI_AUTOFOCUS_DEFAULT_OPTIONS);\nfunction tuiAutoFocusOptionsProvider(options) {\n  return tuiProvideOptions(TUI_AUTOFOCUS_OPTIONS, options, TUI_AUTOFOCUS_DEFAULT_OPTIONS);\n}\nconst TUI_AUTOFOCUS_HANDLER = /*#__PURE__*/new InjectionToken('[TUI_AUTOFOCUS_HANDLER]');\nconst TUI_AUTOFOCUS_PROVIDERS = [{\n  provide: TUI_AUTOFOCUS_HANDLER,\n  useFactory: (focusable, el, animationFrame$, renderer, zone, win, isIos) => isIos ? new TuiIosAutofocusHandler(focusable, el, renderer, zone, win) : new TuiDefaultAutofocusHandler(focusable, el, animationFrame$),\n  deps: [[new Optional(), new Self(), TUI_FOCUSABLE_ITEM_ACCESSOR], ElementRef, ANIMATION_FRAME, Renderer2, NgZone, WINDOW, TUI_IS_IOS]\n}, TuiDestroyService];\nlet TuiAutoFocusDirective = /*#__PURE__*/(() => {\n  class TuiAutoFocusDirective {\n    constructor(handler, options, destroy$) {\n      this.handler = handler;\n      this.options = options;\n      this.destroy$ = destroy$;\n      this.autoFocus = true;\n    }\n    ngAfterViewInit() {\n      if (tuiCoerceBooleanProperty(this.autoFocus)) {\n        this.focus();\n      }\n    }\n    focus() {\n      if (Number.isNaN(this.options.delay)) {\n        void Promise.resolve().then(() => this.handler.setFocus());\n      } else {\n        timer(this.options.delay).pipe(takeUntil(this.destroy$)).subscribe(() => this.handler.setFocus());\n      }\n    }\n  }\n  TuiAutoFocusDirective.ɵfac = function TuiAutoFocusDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiAutoFocusDirective)(i0.ɵɵdirectiveInject(TUI_AUTOFOCUS_HANDLER), i0.ɵɵdirectiveInject(TUI_AUTOFOCUS_OPTIONS), i0.ɵɵdirectiveInject(TuiDestroyService, 2));\n  };\n  TuiAutoFocusDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiAutoFocusDirective,\n    selectors: [[\"\", \"tuiAutoFocus\", \"\"]],\n    inputs: {\n      autoFocus: [0, \"tuiAutoFocus\", \"autoFocus\"]\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature(TUI_AUTOFOCUS_PROVIDERS)]\n  });\n  return TuiAutoFocusDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiAutoFocusModule = /*#__PURE__*/(() => {\n  class TuiAutoFocusModule {}\n  TuiAutoFocusModule.ɵfac = function TuiAutoFocusModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiAutoFocusModule)();\n  };\n  TuiAutoFocusModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TuiAutoFocusModule\n  });\n  TuiAutoFocusModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TuiAutoFocusModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiSynchronousAutofocusHandler = /*#__PURE__*/(() => {\n  class TuiSynchronousAutofocusHandler extends AbstractTuiAutofocusHandler {\n    constructor(focusable, el) {\n      super(focusable, el);\n    }\n    setFocus() {\n      this.element.focus({\n        preventScroll: true\n      });\n    }\n  }\n  TuiSynchronousAutofocusHandler.ɵfac = function TuiSynchronousAutofocusHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiSynchronousAutofocusHandler)(i0.ɵɵdirectiveInject(TUI_FOCUSABLE_ITEM_ACCESSOR, 10), i0.ɵɵdirectiveInject(ElementRef));\n  };\n  TuiSynchronousAutofocusHandler.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiSynchronousAutofocusHandler,\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiSynchronousAutofocusHandler;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AbstractTuiAutofocusHandler, TUI_AUTOFOCUS_DEFAULT_OPTIONS, TUI_AUTOFOCUS_HANDLER, TUI_AUTOFOCUS_OPTIONS, TUI_AUTOFOCUS_PROVIDERS, TuiAutoFocusDirective, TuiAutoFocusModule, TuiDefaultAutofocusHandler, TuiIosAutofocusHandler, TuiSynchronousAutofocusHandler, tuiAutoFocusOptionsProvider };\n//# sourceMappingURL=taiga-ui-cdk-directives-auto-focus.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}