{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { ChangeDetectorRef, ElementRef, Component, ChangeDetectionStrategy, Optional, Self, Inject, Input, HostBinding, ViewChildren, HostListener, EventEmitter, Directive, Output, NgModule } from '@angular/core';\nimport * as i2 from '@angular/forms';\nimport { NgControl, FormsModule } from '@angular/forms';\nimport * as i3 from '@taiga-ui/cdk';\nimport { AbstractTuiControl, EMPTY_QUERY, tuiIsNativeFocusedIn, tuiClamp, tuiQuantize, tuiPure, tuiTypedFromEvent, tuiRound, TuiDestroyService, TuiFocusableModule } from '@taiga-ui/cdk';\nimport * as i1 from '@taiga-ui/kit/components/slider';\nimport { TuiSliderComponent, TuiSliderModule } from '@taiga-ui/kit/components/slider';\nimport { tuiPercentageToKeyStepValue, tuiKeyStepValueToPercentage } from '@taiga-ui/kit/utils';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { TUI_FLOATING_PRECISION } from '@taiga-ui/kit/constants';\nimport * as i2$1 from 'rxjs';\nimport { merge } from 'rxjs';\nimport { filter, map, tap, switchMap, startWith, takeUntil, repeat } from 'rxjs/operators';\nlet TuiRangeComponent = /*#__PURE__*/(() => {\n  class TuiRangeComponent extends AbstractTuiControl {\n    constructor(control, cdr, el) {\n      super(control, cdr);\n      this.el = el;\n      this.min = 0;\n      this.max = 100;\n      this.step = 1;\n      this.size = 'm';\n      this.segments = 1;\n      this.keySteps = null;\n      this.slidersRefs = EMPTY_QUERY;\n      this.lastActiveThumb = 'right';\n    }\n    get nativeFocusableElement() {\n      const [sliderLeftRef, sliderRightRef] = this.slidersRefs;\n      if (this.computedDisabled || !this.focusable || !sliderLeftRef || !sliderRightRef) {\n        return null;\n      }\n      const isLeftThumbLocked = this.right === 100;\n      return isLeftThumbLocked ? sliderRightRef.nativeElement : sliderLeftRef.nativeElement;\n    }\n    get focused() {\n      return tuiIsNativeFocusedIn(this.el.nativeElement);\n    }\n    get fractionStep() {\n      return this.step / (this.max - this.min);\n    }\n    get computedKeySteps() {\n      return this.computePureKeySteps(this.keySteps, this.min, this.max);\n    }\n    get segmentWidthRatio() {\n      return 1 / this.segments;\n    }\n    get left() {\n      return this.getPercentageFromValue(this.value[0]);\n    }\n    get right() {\n      return 100 - this.getPercentageFromValue(this.value[1]);\n    }\n    onFocused(focused) {\n      this.updateFocused(focused);\n    }\n    changeByStep(coefficient, target) {\n      const [sliderLeftRef, sliderRightRef] = this.slidersRefs;\n      const leftThumbElement = sliderLeftRef.nativeElement;\n      const rightThumbElement = sliderRightRef.nativeElement;\n      const isRightThumb = target === this.el.nativeElement ? this.lastActiveThumb === 'right' : target === rightThumbElement;\n      const activeThumbElement = isRightThumb ? rightThumbElement : leftThumbElement;\n      const previousValue = isRightThumb ? this.value[1] : this.value[0];\n      /** @bad TODO think about a solution without twice conversion */\n      const previousFraction = this.getPercentageFromValue(previousValue) / 100;\n      const newFractionValue = previousFraction + coefficient * this.fractionStep;\n      this.processValue(this.getValueFromFraction(newFractionValue), isRightThumb);\n      if (activeThumbElement) {\n        activeThumbElement.focus();\n      }\n    }\n    processValue(value, right) {\n      if (right) {\n        this.updateEnd(value);\n      } else {\n        this.updateStart(value);\n      }\n      this.lastActiveThumb = right ? 'right' : 'left';\n    }\n    getValueFromFraction(fraction) {\n      const guardedFraction = tuiClamp(tuiQuantize(fraction, this.fractionStep), 0, 1);\n      return tuiPercentageToKeyStepValue(guardedFraction * 100, this.computedKeySteps);\n    }\n    getPercentageFromValue(value) {\n      return tuiKeyStepValueToPercentage(value, this.computedKeySteps);\n    }\n    getFallbackValue() {\n      return [0, 0];\n    }\n    computePureKeySteps(keySteps, min, max) {\n      return keySteps || [[0, min], [100, max]];\n    }\n    updateStart(value) {\n      this.value = [Math.min(value, this.value[1]), this.value[1]];\n    }\n    updateEnd(value) {\n      this.value = [this.value[0], Math.max(value, this.value[0])];\n    }\n  }\n  TuiRangeComponent.ɵfac = function TuiRangeComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiRangeComponent)(i0.ɵɵdirectiveInject(NgControl, 10), i0.ɵɵdirectiveInject(ChangeDetectorRef), i0.ɵɵdirectiveInject(ElementRef));\n  };\n  TuiRangeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TuiRangeComponent,\n    selectors: [[\"tui-range\"]],\n    viewQuery: function TuiRangeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TuiSliderComponent, 5, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slidersRefs = _t);\n      }\n    },\n    hostVars: 7,\n    hostBindings: function TuiRangeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focusin\", function TuiRangeComponent_focusin_HostBindingHandler() {\n          return ctx.onFocused(true);\n        })(\"focusout\", function TuiRangeComponent_focusout_HostBindingHandler() {\n          return ctx.onFocused(false);\n        })(\"keydown.arrowUp.prevent\", function TuiRangeComponent_keydown_arrowUp_prevent_HostBindingHandler($event) {\n          return ctx.changeByStep(1, $event.target);\n        })(\"keydown.arrowRight.prevent\", function TuiRangeComponent_keydown_arrowRight_prevent_HostBindingHandler($event) {\n          return ctx.changeByStep(1, $event.target);\n        })(\"keydown.arrowLeft.prevent\", function TuiRangeComponent_keydown_arrowLeft_prevent_HostBindingHandler($event) {\n          return ctx.changeByStep(-1, $event.target);\n        })(\"keydown.arrowDown.prevent\", function TuiRangeComponent_keydown_arrowDown_prevent_HostBindingHandler($event) {\n          return ctx.changeByStep(-1, $event.target);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", -1)(\"aria-disabled\", ctx.computedDisabled)(\"data-size\", ctx.size);\n        i0.ɵɵstyleProp(\"--left\", ctx.left, \"%\")(\"--right\", ctx.right, \"%\");\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      step: \"step\",\n      size: \"size\",\n      segments: \"segments\",\n      keySteps: \"keySteps\"\n    },\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 18,\n    consts: [[1, \"t-track\"], [\"automation-id\", \"tui-range__left\", \"readonly\", \"\", \"step\", \"any\", \"tuiSlider\", \"\", \"type\", \"range\", 1, \"t-thumb\", 3, \"disabled\", \"keySteps\", \"max\", \"min\", \"ngModel\", \"size\", \"tuiFocusable\"], [\"automation-id\", \"tui-range__right\", \"readonly\", \"\", \"step\", \"any\", \"tuiSlider\", \"\", \"type\", \"range\", 1, \"t-thumb\", 3, \"disabled\", \"keySteps\", \"max\", \"min\", \"ngModel\", \"size\", \"tuiFocusable\"]],\n    template: function TuiRangeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"input\", 1)(2, \"input\", 2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"--bg-size-ratio\", 1 - ctx.segmentWidthRatio)(\"--segment-width\", ctx.segmentWidthRatio * 100, \"%\");\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"disabled\", ctx.computedDisabled)(\"keySteps\", ctx.computedKeySteps)(\"max\", ctx.max)(\"min\", ctx.min)(\"ngModel\", ctx.value[0])(\"size\", ctx.size)(\"tuiFocusable\", ctx.focusable);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"disabled\", ctx.computedDisabled)(\"keySteps\", ctx.computedKeySteps)(\"max\", ctx.max)(\"min\", ctx.min)(\"ngModel\", ctx.value[1])(\"size\", ctx.size)(\"tuiFocusable\", ctx.focusable);\n      }\n    },\n    dependencies: [i1.TuiSliderComponent, i1.TuiSliderReadonlyDirective, i1.TuiSliderKeyStepsDirective, i2.RangeValueAccessor, i2.DefaultValueAccessor, i2.NgControlStatus, i2.NgModel, i3.TuiFocusableDirective],\n    styles: [\"[_nghost-%COMP%]{position:relative;display:block;height:.125rem;border-radius:var(--tui-radius-m);background:var(--tui-base-03);cursor:pointer;outline:none;margin:.4375rem 0;touch-action:pan-x}[_nghost-%COMP%]:active{cursor:ew-resize}[_nghost-%COMP%]:after{content:\\\"\\\";position:absolute;top:-.4375rem;bottom:-.4375rem;width:100%}._disabled[_nghost-%COMP%]{opacity:var(--tui-disabled-opacity);cursor:auto}[data-size=s][_nghost-%COMP%]   .t-track[_ngcontent-%COMP%]{position:relative;margin:0 .25rem;height:100%}[data-size=s][_nghost-%COMP%]   .t-track[_ngcontent-%COMP%]:before{content:\\\"\\\";position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 calc(-.5rem / 2 - 1px)}[data-size=s][_nghost-%COMP%]   .t-track[_ngcontent-%COMP%]:after{position:absolute;top:0;left:0;bottom:0;right:0;content:\\\"\\\";left:.125rem;right:.375rem;background-image:repeating-linear-gradient(to right,var(--tui-base-06) 0 .25rem,transparent 0 calc(var(--segment-width) / var(--bg-size-ratio)));background-position-x:right;background-repeat:no-repeat;background-size:calc(100% * var(--bg-size-ratio))}[data-size=m][_nghost-%COMP%]   .t-track[_ngcontent-%COMP%]{position:relative;margin:0 .375rem;height:100%}[data-size=m][_nghost-%COMP%]   .t-track[_ngcontent-%COMP%]:before{content:\\\"\\\";position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 calc(-.75rem / 2 - 1px)}[data-size=m][_nghost-%COMP%]   .t-track[_ngcontent-%COMP%]:after{position:absolute;top:0;left:0;bottom:0;right:0;content:\\\"\\\";left:.25rem;right:.5rem;background-image:repeating-linear-gradient(to right,var(--tui-base-06) 0 .25rem,transparent 0 calc(var(--segment-width) / var(--bg-size-ratio)));background-position-x:right;background-repeat:no-repeat;background-size:calc(100% * var(--bg-size-ratio))}.t-thumb[_ngcontent-%COMP%]{pointer-events:none;position:absolute;top:.0625rem;left:0;right:0;z-index:1;transform:translateY(-50%);margin:0}.t-thumb[_ngcontent-%COMP%]::-webkit-slider-thumb{pointer-events:all}.t-thumb[_ngcontent-%COMP%]::-moz-range-thumb{pointer-events:all}input[type=range].t-thumb[_ngcontent-%COMP%]::-webkit-slider-runnable-track{background:transparent}input[type=range].t-thumb[_ngcontent-%COMP%]::-moz-range-track{background:transparent}input[type=range].t-thumb[_ngcontent-%COMP%]::-moz-range-progress{background:transparent}input[type=range].t-thumb[_ngcontent-%COMP%]::-ms-track{background:transparent}input[type=range].t-thumb[_ngcontent-%COMP%]::-ms-fill-lower{background:transparent}.t-thumb[_ngcontent-%COMP%]:last-of-type{--tui-slider-thumb-transform: translateX(50%) translateX(1px)}.t-thumb[_ngcontent-%COMP%]:first-of-type{--tui-slider-thumb-transform: translateX(-50%) translateX(-1px)}._disabled[_nghost-%COMP%]   .t-thumb[_ngcontent-%COMP%]{opacity:1}\"],\n    changeDetection: 0\n  });\n  __decorate([tuiPure], TuiRangeComponent.prototype, \"computePureKeySteps\", null);\n  return TuiRangeComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiRangeChangeDirective = /*#__PURE__*/(() => {\n  class TuiRangeChangeDirective {\n    constructor(doc, el, range, destroy$) {\n      this.doc = doc;\n      this.el = el;\n      this.range = range;\n      /**\n       * TODO replace with pointer events (when all supported browsers can handle them).\n       * Don't forget to use setPointerCapture instead of listening all doc events\n       */\n      this.pointerDown$ = merge(tuiTypedFromEvent(this.el.nativeElement, 'touchstart', {\n        passive: true\n      }).pipe(filter(({\n        touches\n      }) => touches.length === 1), map(({\n        touches\n      }) => touches[0])), tuiTypedFromEvent(this.el.nativeElement, 'mousedown', {\n        passive: true\n      }));\n      this.pointerMove$ = merge(tuiTypedFromEvent(this.doc, 'touchmove').pipe(filter(({\n        touches\n      }) => touches.length === 1), map(({\n        touches\n      }) => touches[0])), tuiTypedFromEvent(this.doc, 'mousemove'));\n      this.pointerUp$ = merge(tuiTypedFromEvent(this.doc, 'touchend', {\n        passive: true\n      }), tuiTypedFromEvent(this.doc, 'mouseup', {\n        passive: true\n      }));\n      this.activeThumbChange = new EventEmitter();\n      let activeThumb;\n      this.pointerDown$.pipe(tap(({\n        clientX,\n        target\n      }) => {\n        activeThumb = this.detectActiveThumb(clientX, target);\n        this.activeThumbChange.emit(activeThumb);\n        if (this.range.focusable) {\n          el.nativeElement.focus();\n        }\n      }), switchMap(event => this.pointerMove$.pipe(startWith(event))), map(({\n        clientX\n      }) => this.getFractionFromEvents(clientX)), takeUntil(this.pointerUp$), repeat(), takeUntil(destroy$)).subscribe(fraction => {\n        const value = this.range.getValueFromFraction(fraction);\n        this.range.processValue(value, activeThumb === 'right');\n      });\n    }\n    getFractionFromEvents(clickClientX) {\n      const hostRect = this.el.nativeElement.getBoundingClientRect();\n      const value = clickClientX - hostRect.left;\n      const total = hostRect.width;\n      return tuiClamp(tuiRound(value / total, TUI_FLOATING_PRECISION), 0, 1);\n    }\n    detectActiveThumb(clientX, target) {\n      const [leftSliderRef, rightSliderRef] = this.range.slidersRefs;\n      switch (target) {\n        case leftSliderRef.nativeElement:\n          return 'left';\n        case rightSliderRef.nativeElement:\n          return 'right';\n        default:\n          return this.findNearestActiveThumb(clientX);\n      }\n    }\n    findNearestActiveThumb(clientX) {\n      const fraction = this.getFractionFromEvents(clientX);\n      const deltaLeft = fraction * 100 - this.range.left;\n      const deltaRight = fraction * 100 - 100 + this.range.right;\n      return Math.abs(deltaLeft) > Math.abs(deltaRight) || deltaRight > 0 || this.range.left === 0 && this.range.right === 100 ? 'right' : 'left';\n    }\n  }\n  TuiRangeChangeDirective.ɵfac = function TuiRangeChangeDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiRangeChangeDirective)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(TuiRangeComponent), i0.ɵɵdirectiveInject(TuiDestroyService, 2));\n  };\n  TuiRangeChangeDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiRangeChangeDirective,\n    selectors: [[\"tui-range\"]],\n    outputs: {\n      activeThumbChange: \"activeThumbChange\"\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([TuiDestroyService])]\n  });\n  return TuiRangeChangeDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiRangeModule = /*#__PURE__*/(() => {\n  class TuiRangeModule {}\n  TuiRangeModule.ɵfac = function TuiRangeModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiRangeModule)();\n  };\n  TuiRangeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TuiRangeModule\n  });\n  TuiRangeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, TuiFocusableModule, TuiSliderModule, FormsModule]]\n  });\n  return TuiRangeModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TuiRangeChangeDirective, TuiRangeComponent, TuiRangeModule };\n//# sourceMappingURL=taiga-ui-kit-components-range.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}