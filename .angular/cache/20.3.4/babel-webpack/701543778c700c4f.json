{"ast":null,"code":"import { svgNodeFilter, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_SPACE } from '@taiga-ui/cdk';\nfunction tuiCheckFixedPosition(element) {\n  if (!element || typeof getComputedStyle === 'undefined') {\n    return false;\n  }\n  const style = getComputedStyle(element);\n  return style.getPropertyValue('position') === 'fixed' || tuiCheckFixedPosition(element.parentElement);\n}\n\n/**\n * Calculates size of safe area on mobile devices (status bars)\n *\n * ATTENTION: Only use in browser environment\n */\nfunction tuiGetSafeAreaSize() {\n  if (!CSS.supports('padding-top: env(safe-area-inset-top)')) {\n    return 0;\n  }\n  const div = document.createElement('div');\n  div.style.paddingTop = 'env(safe-area-inset-top)';\n  document.body.appendChild(div);\n  const safeAreaSize = parseInt(window.getComputedStyle(div).paddingTop, 10) || 0;\n  document.body.removeChild(div);\n  return safeAreaSize;\n}\nfunction tuiGetScreenWidth(doc) {\n  return Math.max(doc.documentElement.clientWidth, doc.defaultView ? doc.defaultView.innerWidth : 0);\n}\n\n/**\n * @description:\n * Cross-browser @media (height)\n *\n * 1. window.innerWidth\n * 1.1. gets CSS viewport @media (height) which include scrollbars\n * 1.2. initial-scale and zoom variations may cause mobile values to\n *      wrongly scale down to what PPK calls the visual\n *      viewport and be smaller than the @media values\n *  1.3. zoom may cause values to be 1px off due to native rounding\n *\n *  2. document.documentElement.clientHeight\n *  2.1. equals CSS viewport width minus scrollbar width\n *  2.2. matches @media (height) when there is no scrollbar\n *  2.3. available cross-browser\n *  2.4. inaccurate if doctype is missing\n */\nfunction tuiGetViewportHeight({\n  document,\n  innerHeight\n}) {\n  return Math.max(document.documentElement.clientHeight || 0, innerHeight || 0);\n}\n\n/**\n * @description:\n * Cross-browser @media (width)\n *\n * 1. window.innerWidth\n * 1.1. gets CSS viewport @media (width) which include scrollbars\n * 1.2. initial-scale and zoom variations may cause mobile values to\n *      wrongly scale down to what PPK calls the visual\n *      viewport and be smaller than the @media values\n *  1.3. zoom may cause values to be 1px off due to native rounding\n *\n *  2. document.documentElement.clientWidth\n *  2.1. equals CSS viewport width minus scrollbar width\n *  2.2. matches @media (width) when there is no scrollbar\n *  2.3. available cross-browser\n *  2.4. inaccurate if doctype is missing\n */\nfunction tuiGetViewportWidth({\n  document,\n  innerWidth\n}) {\n  return Math.max(document.documentElement.clientWidth || 0, innerWidth || 0);\n}\n\n/**\n * Creates a cloned range with its boundaries set at word boundaries\n *\n * @param currentRange a range to clone\n * @return modified range\n */\nfunction tuiGetWordRange(currentRange) {\n  const range = currentRange.cloneRange();\n  const {\n    startContainer,\n    startOffset,\n    endContainer,\n    endOffset\n  } = range;\n  const {\n    ownerDocument\n  } = startContainer;\n  if (!ownerDocument) {\n    return range;\n  }\n  const treeWalker = ownerDocument.createTreeWalker(ownerDocument.body, NodeFilter.SHOW_TEXT, svgNodeFilter);\n  treeWalker.currentNode = startContainer;\n  do {\n    const container = treeWalker.currentNode;\n    const textContent = container.textContent || '';\n    const content = container === startContainer ? textContent.slice(0, Math.max(0, startOffset + 1)) : textContent;\n    const offset = Math.max(content.lastIndexOf(' '), content.lastIndexOf(CHAR_NO_BREAK_SPACE), content.lastIndexOf(CHAR_ZERO_WIDTH_SPACE)) + 1;\n    range.setStart(container, 0);\n    if (offset) {\n      range.setStart(container, offset);\n      break;\n    }\n  } while (treeWalker.previousNode());\n  treeWalker.currentNode = endContainer;\n  do {\n    const container = treeWalker.currentNode;\n    const textContent = container.textContent || '';\n    const content = container === endContainer ? textContent.slice(endOffset + 1) : textContent;\n    const offset = [content.indexOf(' '), content.indexOf(CHAR_NO_BREAK_SPACE), content.indexOf(CHAR_ZERO_WIDTH_SPACE)].reduce((result, item) => result === -1 || item === -1 ? Math.max(result, item) : Math.min(result, item), -1);\n    range.setEnd(container, textContent.length);\n    if (offset !== -1) {\n      range.setEnd(container, offset + textContent.length - content.length);\n      break;\n    }\n  } while (treeWalker.nextNode());\n  return range;\n}\nconst WIDTH_SEARCH = 'width=\"';\nconst HEIGHT_SEARCH = 'height=\"';\nconst START = '<svg';\nfunction tuiProcessIcon(source, name) {\n  if (source.includes(`id=\"${name}\"`)) {\n    return source;\n  }\n  const src = source.slice(Math.max(0, source.indexOf(START)));\n  const attributes = src.slice(0, Math.max(0, src.indexOf('>')));\n  if (!(attributes === null || attributes === void 0 ? void 0 : attributes.includes(WIDTH_SEARCH)) || !attributes.includes(HEIGHT_SEARCH)) {\n    return `${src.replace(START, `<svg xmlns=\"http://www.w3.org/2000/svg\"><g id=\"${name}\" xmlns=\"http://www.w3.org/2000/svg\"><svg`)}</g></svg>`;\n  }\n  const indexOfWidth = attributes.indexOf(WIDTH_SEARCH);\n  const indexOfHeight = attributes.indexOf(HEIGHT_SEARCH);\n  const widthOffset = indexOfWidth + WIDTH_SEARCH.length;\n  const heightOffset = indexOfHeight + HEIGHT_SEARCH.length;\n  const widthString = attributes.slice(widthOffset, attributes.indexOf('\"', widthOffset));\n  const heightString = attributes.slice(heightOffset, attributes.indexOf('\"', heightOffset));\n  if (!heightString || !widthString || widthString.includes('%') || heightString.includes('%') || widthString.includes('em') || heightString.includes('em')) {\n    return src.replace(START, `<svg id=\"${name}\"`);\n  }\n  const width = parseInt(widthString, 10);\n  const height = parseInt(heightString, 10);\n  return `<g id=\"${name}\" xmlns=\"http://www.w3.org/2000/svg\"><svg  x=\"50%\" y=\"50%\" width=\"${width / 16}em\" height=\"${height / 16}em\" overflow=\"visible\" viewBox=\"0 0 ${width} ${height}\"><svg x=\"${-width / 2}\" y=\"${-height / 2}\">${src}</svg></svg></g>`;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCheckFixedPosition, tuiGetSafeAreaSize, tuiGetScreenWidth, tuiGetViewportHeight, tuiGetViewportWidth, tuiGetWordRange, tuiProcessIcon };\n//# sourceMappingURL=taiga-ui-core-utils-dom.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}