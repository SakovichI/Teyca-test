{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, ElementRef, INJECTOR, Self, Inject, Optional, SkipSelf, forwardRef, Component, ChangeDetectionStrategy, HostBinding, HostListener, ViewContainerRef, NgModule } from '@angular/core';\nimport { WINDOW } from '@ng-web-apis/common';\nimport * as i2 from '@taiga-ui/cdk';\nimport { tuiCreateTokenFromFactory, TuiDestroyService, TuiDropdownPortalService, tuiPure, tuiCreateToken, tuiProvideOptions, TuiHoveredService, EMPTY_CLIENT_RECT, tuiPx, tuiGetClosestFocusable, tuiPointToClientRect, TuiActiveZoneDirective, TUI_IS_IOS, TUI_IS_TOUCH, ALWAYS_TRUE_HANDLER, tuiIsTextNode, tuiIsString, tuiIsElement, tuiGetNativeFocused, tuiIsTextfield, CHAR_ZERO_WIDTH_SPACE, CHAR_NO_BREAK_SPACE, TUI_RANGE, TuiActiveZoneModule, TuiOverscrollModule, TuiHoveredModule } from '@taiga-ui/cdk';\nimport * as i1$1 from '@taiga-ui/core/abstract';\nimport { tuiAsRectAccessor, tuiAsVehicle, TuiDriver, tuiAsDriver, TuiPositionAccessor, tuiFallbackRectAccessor, TuiRectAccessor, tuiPositionAccessorFor, tuiRectAccessorFor, AbstractTuiDriverDirective, TuiVehicle, tuiAsPositionAccessor } from '@taiga-ui/core/abstract';\nimport { tuiDropdownAnimation } from '@taiga-ui/core/animations';\nimport { MODE_PROVIDER } from '@taiga-ui/core/providers';\nimport * as i4 from '@taiga-ui/core/services';\nimport { TuiVisualViewportService, TuiPositionService } from '@taiga-ui/core/services';\nimport { TUI_VIEWPORT, TUI_ANIMATION_OPTIONS, TUI_MODE, TUI_SELECTION_STREAM } from '@taiga-ui/core/tokens';\nimport { throttleTime, takeUntil, switchMap, delay, tap, share, map, distinctUntilChanged } from 'rxjs/operators';\nimport { __decorate } from 'tslib';\nimport { tuiCheckFixedPosition, tuiOverrideOptions, tuiGetWordRange } from '@taiga-ui/core/utils';\nimport * as i3 from '@tinkoff/ng-polymorpheus';\nimport { PolymorpheusComponent, PolymorpheusModule } from '@tinkoff/ng-polymorpheus';\nimport * as i1 from 'rxjs';\nimport { Subject, merge, of, BehaviorSubject, combineLatest } from 'rxjs';\nimport * as i1$2 from '@taiga-ui/core/components/scrollbar';\nimport { TuiScrollbarModule } from '@taiga-ui/core/components/scrollbar';\nimport { shouldCall } from '@tinkoff/ng-event-plugins';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * A component to display a dropdown\n */\nconst _c0 = a0 => ({\n  $implicit: a0\n});\nfunction TuiDropdownComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const text_r2 = ctx.polymorpheusOutlet;\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", text_r2, \" \");\n  }\n}\nconst TUI_DROPDOWN_COMPONENT = tuiCreateTokenFromFactory(() => TuiDropdownComponent);\nlet TuiDropdownOpenDirective = /*#__PURE__*/(() => {\n  class TuiDropdownOpenDirective {\n    constructor() {\n      this.tuiDropdownOpen = false;\n      this.tuiDropdownOpenChange = new EventEmitter();\n    }\n    update(open) {\n      this.tuiDropdownOpen = open;\n      this.tuiDropdownOpenChange.emit(open);\n    }\n    ngOnChanges() {\n      var _a;\n      (_a = this.dropdown) === null || _a === void 0 ? void 0 : _a.toggle(this.tuiDropdownOpen);\n    }\n  }\n  TuiDropdownOpenDirective.ɵfac = function TuiDropdownOpenDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownOpenDirective)();\n  };\n  TuiDropdownOpenDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownOpenDirective,\n    selectors: [[\"\", \"tuiDropdownOpen\", \"\"], [\"\", \"tuiDropdownOpenChange\", \"\"]],\n    inputs: {\n      tuiDropdownOpen: \"tuiDropdownOpen\"\n    },\n    outputs: {\n      tuiDropdownOpenChange: \"tuiDropdownOpenChange\"\n    },\n    standalone: false,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TuiDropdownOpenDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownDirective = /*#__PURE__*/(() => {\n  class TuiDropdownDirective {\n    constructor(destroy$, el, dropdown, injector, dropdownService, open) {\n      this.el = el;\n      this.dropdown = dropdown;\n      this.injector = injector;\n      this.dropdownService = dropdownService;\n      this.open = open;\n      this.refresh$ = new Subject();\n      this.dropdownBoxRef = null;\n      this.type = 'dropdown';\n      this.component = new PolymorpheusComponent(this.dropdown, this.injector);\n      if (this.open && !this.open.dropdown) {\n        this.open.dropdown = this;\n      } else {\n        this.open = null;\n      }\n      // Ignore multiple change detection triggers at the same frame\n      this.refresh$.pipe(throttleTime(0), takeUntil(destroy$)).subscribe(() => {\n        var _a, _b;\n        (_a = this.dropdownBoxRef) === null || _a === void 0 ? void 0 : _a.changeDetectorRef.detectChanges();\n        (_b = this.dropdownBoxRef) === null || _b === void 0 ? void 0 : _b.changeDetectorRef.markForCheck();\n      });\n    }\n    get position() {\n      return tuiCheckFixedPosition(this.el.nativeElement) ? 'fixed' : 'absolute';\n    }\n    ngAfterViewChecked() {\n      this.refresh$.next();\n    }\n    ngAfterViewInit() {\n      if (this.open) {\n        this.toggle(this.open.tuiDropdownOpen);\n      }\n    }\n    ngOnChanges() {\n      if (!this.content) {\n        this.toggle(false);\n      }\n    }\n    ngOnDestroy() {\n      this.toggle(false);\n      if (this.open) {\n        this.open.dropdown = undefined;\n      }\n    }\n    getClientRect() {\n      return this.el.nativeElement.getBoundingClientRect();\n    }\n    toggle(show) {\n      var _a, _b;\n      if (show && this.content && !this.dropdownBoxRef) {\n        this.dropdownBoxRef = this.dropdownService.add(this.component);\n        (_a = this.open) === null || _a === void 0 ? void 0 : _a.update(true);\n      } else if (!show && this.dropdownBoxRef) {\n        this.dropdownService.remove(this.dropdownBoxRef);\n        this.dropdownBoxRef = null;\n        (_b = this.open) === null || _b === void 0 ? void 0 : _b.update(false);\n      }\n    }\n  }\n  TuiDropdownDirective.ɵfac = function TuiDropdownDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownDirective)(i0.ɵɵdirectiveInject(TuiDestroyService, 2), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(TUI_DROPDOWN_COMPONENT), i0.ɵɵdirectiveInject(INJECTOR), i0.ɵɵdirectiveInject(TuiDropdownPortalService), i0.ɵɵdirectiveInject(TuiDropdownOpenDirective, 8));\n  };\n  TuiDropdownDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownDirective,\n    selectors: [[\"\", \"tuiDropdown\", \"\", 5, \"ng-container\"]],\n    inputs: {\n      content: [0, \"tuiDropdown\", \"content\"]\n    },\n    exportAs: [\"tuiDropdown\"],\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([TuiDestroyService, tuiAsRectAccessor(TuiDropdownDirective), tuiAsVehicle(TuiDropdownDirective)]), i0.ɵɵNgOnChangesFeature]\n  });\n  __decorate([tuiPure], TuiDropdownDirective.prototype, \"position\", null);\n  return TuiDropdownDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Default values for hint options */\nconst TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS = {\n  showDelay: 200,\n  hideDelay: 500\n};\n/**\n * Default parameters for dropdown hover directive\n */\nconst TUI_DROPDOWN_HOVER_OPTIONS = tuiCreateToken(TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS);\nfunction tuiDropdownHoverOptionsProvider(options) {\n  return tuiProvideOptions(TUI_DROPDOWN_HOVER_OPTIONS, options, TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS);\n}\nlet TuiDropdownHoverDirective = /*#__PURE__*/(() => {\n  class TuiDropdownHoverDirective extends TuiDriver {\n    constructor(hovered$, options, parentHover) {\n      super(subscriber => this.stream$.subscribe(subscriber));\n      this.hovered$ = hovered$;\n      this.options = options;\n      this.parentHover = parentHover;\n      this.toggle$ = new Subject();\n      this.stream$ = merge(this.toggle$, this.hovered$).pipe(switchMap(visible => of(visible).pipe(delay(visible ? this.showDelay : this.hideDelay))), tap(visible => {\n        this.hovered = visible;\n      }), share());\n      this.showDelay = this.options.showDelay;\n      this.hideDelay = this.options.hideDelay;\n      this.hovered = false;\n      this.type = 'dropdown';\n    }\n    toggle(visible) {\n      var _a;\n      (_a = this.parentHover) === null || _a === void 0 ? void 0 : _a.toggle(visible);\n      this.toggle$.next(visible);\n    }\n  }\n  TuiDropdownHoverDirective.ɵfac = function TuiDropdownHoverDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownHoverDirective)(i0.ɵɵdirectiveInject(TuiHoveredService), i0.ɵɵdirectiveInject(TUI_DROPDOWN_HOVER_OPTIONS), i0.ɵɵdirectiveInject(TuiDropdownHoverDirective, 12));\n  };\n  TuiDropdownHoverDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownHoverDirective,\n    selectors: [[\"\", \"tuiDropdownHover\", \"\", 5, \"ng-container\"]],\n    inputs: {\n      showDelay: [0, \"tuiDropdownShowDelay\", \"showDelay\"],\n      hideDelay: [0, \"tuiDropdownHideDelay\", \"hideDelay\"]\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([tuiAsDriver(TuiDropdownHoverDirective), TuiHoveredService]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiDropdownHoverDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Default values for dropdown options */\nconst TUI_DROPDOWN_DEFAULT_OPTIONS = {\n  align: 'left',\n  direction: null,\n  limitWidth: 'auto',\n  maxHeight: 400,\n  minHeight: 80,\n  offset: 4,\n  appearance: ''\n};\n/**\n * Default parameters for dropdown directive\n */\nconst TUI_DROPDOWN_OPTIONS = tuiCreateToken(TUI_DROPDOWN_DEFAULT_OPTIONS);\nconst tuiDropdownOptionsProvider = override => ({\n  provide: TUI_DROPDOWN_OPTIONS,\n  deps: [[new Optional(), TuiDropdownOptionsDirective], [new Optional(), new SkipSelf(), TUI_DROPDOWN_OPTIONS]],\n  useFactory: tuiOverrideOptions(override, TUI_DROPDOWN_DEFAULT_OPTIONS)\n});\nlet TuiDropdownOptionsDirective = /*#__PURE__*/(() => {\n  class TuiDropdownOptionsDirective {\n    constructor(options) {\n      this.options = options;\n      this.align = this.options.align;\n      this.appearance = this.options.appearance;\n      this.direction = this.options.direction;\n      this.limitWidth = this.options.limitWidth;\n      this.minHeight = this.options.minHeight;\n      this.maxHeight = this.options.maxHeight;\n      this.offset = this.options.offset;\n    }\n  }\n  TuiDropdownOptionsDirective.ɵfac = function TuiDropdownOptionsDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownOptionsDirective)(i0.ɵɵdirectiveInject(TUI_DROPDOWN_OPTIONS, 4));\n  };\n  TuiDropdownOptionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownOptionsDirective,\n    selectors: [[\"\", \"tuiDropdownAlign\", \"\"], [\"\", \"tuiDropdownAppearance\", \"\"], [\"\", \"tuiDropdownDirection\", \"\"], [\"\", \"tuiDropdownLimitWidth\", \"\"], [\"\", \"tuiDropdownMinHeight\", \"\"], [\"\", \"tuiDropdownMaxHeight\", \"\"], [\"\", \"tuiDropdownOffset\", \"\"]],\n    inputs: {\n      align: [0, \"tuiDropdownAlign\", \"align\"],\n      appearance: [0, \"tuiDropdownAppearance\", \"appearance\"],\n      direction: [0, \"tuiDropdownDirection\", \"direction\"],\n      limitWidth: [0, \"tuiDropdownLimitWidth\", \"limitWidth\"],\n      minHeight: [0, \"tuiDropdownMinHeight\", \"minHeight\"],\n      maxHeight: [0, \"tuiDropdownMaxHeight\", \"maxHeight\"],\n      offset: [0, \"tuiDropdownOffset\", \"offset\"]\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: TUI_DROPDOWN_OPTIONS,\n      useExisting: forwardRef(() => TuiDropdownOptionsDirective)\n    }])]\n  });\n  return TuiDropdownOptionsDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownPositionDirective = /*#__PURE__*/(() => {\n  class TuiDropdownPositionDirective extends TuiPositionAccessor {\n    constructor(options, viewport, accessors, directive) {\n      super();\n      this.options = options;\n      this.viewport = viewport;\n      this.accessors = accessors;\n      this.directive = directive;\n      this.type = 'dropdown';\n    }\n    getPosition({\n      width,\n      height\n    }) {\n      var _a, _b;\n      if (!width && !height) {\n        this.previous = undefined;\n      }\n      const hostRect = (_b = (_a = this.accessor) === null || _a === void 0 ? void 0 : _a.getClientRect()) !== null && _b !== void 0 ? _b : EMPTY_CLIENT_RECT;\n      const viewportRect = this.viewport.getClientRect();\n      const {\n        minHeight,\n        align,\n        direction,\n        offset,\n        limitWidth\n      } = this.options;\n      const viewport = {\n        top: viewportRect.top - offset,\n        bottom: viewportRect.bottom + offset,\n        right: viewportRect.right - offset,\n        left: viewportRect.left + offset\n      };\n      const previous = this.previous || direction || 'bottom';\n      const available = {\n        top: hostRect.top - 2 * offset - viewport.top,\n        bottom: viewport.bottom - hostRect.bottom - 2 * offset\n      };\n      const rectWidth = limitWidth === 'fixed' ? hostRect.width : width;\n      const right = Math.max(hostRect.right - rectWidth, offset);\n      const left = hostRect.left + width < viewport.right ? hostRect.left : right;\n      const position = {\n        top: hostRect.top - offset - height,\n        bottom: hostRect.bottom + offset,\n        right: Math.max(viewport.left, right),\n        center: hostRect.left + hostRect.width / 2 + width / 2 < viewport.right ? hostRect.left + hostRect.width / 2 - width / 2 : right,\n        left: Math.max(viewport.left, left)\n      };\n      const better = available.top > available.bottom ? 'top' : 'bottom';\n      if (available[previous] > minHeight && direction || available[previous] > height) {\n        return [position[previous], position[align]];\n      }\n      this.previous = better;\n      return [position[better], position[align]];\n    }\n    get accessor() {\n      return tuiFallbackRectAccessor('dropdown')(this.accessors, this.directive);\n    }\n  }\n  TuiDropdownPositionDirective.ɵfac = function TuiDropdownPositionDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownPositionDirective)(i0.ɵɵdirectiveInject(TUI_DROPDOWN_OPTIONS), i0.ɵɵdirectiveInject(TUI_VIEWPORT), i0.ɵɵdirectiveInject(TuiRectAccessor), i0.ɵɵdirectiveInject(TuiDropdownDirective));\n  };\n  TuiDropdownPositionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownPositionDirective,\n    selectors: [[\"\", \"tuiDropdown\", \"\"]],\n    standalone: false,\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  __decorate([tuiPure], TuiDropdownPositionDirective.prototype, \"accessor\", null);\n  return TuiDropdownPositionDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @description:\n * This component is used to show template in a portal\n * using default style of white rounded box with a shadow\n */\nlet TuiDropdownComponent = /*#__PURE__*/(() => {\n  class TuiDropdownComponent {\n    constructor(vvs, position$, destroy$, directive, animation, el, accessor, win, mode$, options, hoverDirective) {\n      this.directive = directive;\n      this.animation = animation;\n      this.el = el;\n      this.accessor = accessor;\n      this.win = win;\n      this.mode$ = mode$;\n      this.options = options;\n      this.hoverDirective = hoverDirective;\n      position$.pipe(map(point => this.directive.position === 'fixed' ? vvs.correct(point) : point), takeUntil(destroy$)).subscribe(([top, left]) => {\n        if (this.directive.el.nativeElement.isConnected) {\n          this.update(top, left);\n        } else {\n          this.directive.toggle(false);\n        }\n      });\n      this.updateWidth(this.accessor.getClientRect().width);\n    }\n    onHoveredChange(hovered) {\n      var _a;\n      (_a = this.hoverDirective) === null || _a === void 0 ? void 0 : _a.toggle(hovered);\n    }\n    onTopFocus() {\n      this.moveFocusOutside(true);\n    }\n    onBottomFocus() {\n      this.moveFocusOutside(false);\n    }\n    update(top, left) {\n      var _a;\n      const {\n        style\n      } = this.el.nativeElement;\n      const {\n        right\n      } = this.el.nativeElement.getBoundingClientRect();\n      const {\n        maxHeight,\n        minHeight,\n        offset\n      } = this.options;\n      const {\n        innerHeight\n      } = this.win;\n      const clientRect = (_a = this.el.nativeElement.offsetParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n      const {\n        position\n      } = this.directive;\n      const rect = this.accessor.getClientRect();\n      const offsetX = position === 'fixed' ? 0 : -((clientRect === null || clientRect === void 0 ? void 0 : clientRect.left) || 0);\n      const offsetY = position === 'fixed' ? 0 : -((clientRect === null || clientRect === void 0 ? void 0 : clientRect.top) || 0);\n      top += offsetY;\n      left += offsetX;\n      const isIntersecting = left < rect.right && right > rect.left && top < offsetY + 2 * offset;\n      const available = isIntersecting ? rect.top - 2 * offset : offsetY + innerHeight - top - offset;\n      const sided = right <= rect.left || left >= rect.right;\n      style.position = position;\n      style.top = tuiPx(Math.max(top, offsetY + offset));\n      style.left = tuiPx(left);\n      style.maxHeight = sided ? `${maxHeight}px` : tuiPx(Math.min(maxHeight, Math.max(available, minHeight)));\n      style.width = '';\n      style.minWidth = '';\n      this.updateWidth(rect.width);\n    }\n    updateWidth(width) {\n      const {\n        style\n      } = this.el.nativeElement;\n      switch (this.options.limitWidth) {\n        case 'min':\n          style.minWidth = tuiPx(width);\n          break;\n        case 'fixed':\n          style.width = tuiPx(width);\n          break;\n        case 'auto':\n          break;\n      }\n    }\n    moveFocusOutside(previous) {\n      const {\n        nativeElement\n      } = this.directive.el;\n      const {\n        ownerDocument\n      } = nativeElement;\n      const root = ownerDocument ? ownerDocument.body : nativeElement;\n      let focusable = tuiGetClosestFocusable({\n        initial: nativeElement,\n        root,\n        previous\n      });\n      while (focusable !== null && nativeElement.contains(focusable)) {\n        focusable = tuiGetClosestFocusable({\n          initial: focusable,\n          root,\n          previous\n        });\n      }\n      focusable === null || focusable === void 0 ? void 0 : focusable.focus();\n    }\n  }\n  TuiDropdownComponent.ɵfac = function TuiDropdownComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownComponent)(i0.ɵɵdirectiveInject(TuiVisualViewportService), i0.ɵɵdirectiveInject(TuiPositionService), i0.ɵɵdirectiveInject(TuiDestroyService, 2), i0.ɵɵdirectiveInject(TuiDropdownDirective), i0.ɵɵdirectiveInject(TUI_ANIMATION_OPTIONS), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(TuiRectAccessor), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(TUI_MODE), i0.ɵɵdirectiveInject(TUI_DROPDOWN_OPTIONS), i0.ɵɵdirectiveInject(TuiDropdownHoverDirective, 8));\n  };\n  TuiDropdownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TuiDropdownComponent,\n    selectors: [[\"tui-dropdown\"]],\n    hostVars: 2,\n    hostBindings: function TuiDropdownComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"$.data-mode.attr\", function TuiDropdownComponent___data_mode_attr_HostBindingHandler() {\n          return ctx.mode$;\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@tuiDropdownAnimation\", ctx.animation);\n        i0.ɵɵattribute(\"data-appearance\", ctx.options.appearance);\n      }\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([TuiDestroyService, TuiPositionService, tuiPositionAccessorFor('dropdown', TuiDropdownPositionDirective), tuiRectAccessorFor('dropdown', TuiDropdownDirective), MODE_PROVIDER])],\n    decls: 5,\n    vars: 4,\n    consts: [[\"activeZone\", \"tuiActiveZone\"], [\"tuiActiveZone\", \"\", \"tuiOverscroll\", \"all\", 1, \"t-scroll\", 3, \"tuiHoveredChange\"], [\"tabindex\", \"0\", 3, \"focus\"], [\"class\", \"t-primitive\", 4, \"polymorpheusOutlet\", \"polymorpheusOutletContext\"], [1, \"t-primitive\"]],\n    template: function TuiDropdownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r1 = i0.ɵɵgetCurrentView();\n        i0.ɵɵelementStart(0, \"tui-scrollbar\", 1, 0);\n        i0.ɵɵlistener(\"tuiHoveredChange\", function TuiDropdownComponent_Template_tui_scrollbar_tuiHoveredChange_0_listener($event) {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx.onHoveredChange($event));\n        });\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵlistener(\"focus\", function TuiDropdownComponent_Template_div_focus_2_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx.onTopFocus());\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, TuiDropdownComponent_div_3_Template, 2, 1, \"div\", 3);\n        i0.ɵɵelementStart(4, \"div\", 2);\n        i0.ɵɵlistener(\"focus\", function TuiDropdownComponent_Template_div_focus_4_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx.onBottomFocus());\n        });\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        const activeZone_r3 = i0.ɵɵreference(1);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"polymorpheusOutlet\", ctx.directive.content)(\"polymorpheusOutletContext\", i0.ɵɵpureFunction1(2, _c0, activeZone_r3));\n      }\n    },\n    dependencies: [i1$2.TuiScrollbarComponent, i2.TuiActiveZoneDirective, i2.TuiOverscrollDirective, i2.TuiHoveredDirective, i3.PolymorpheusOutletDirective],\n    styles: [\"[_nghost-%COMP%]{position:absolute;display:flex;box-shadow:var(--tui-shadow-dropdown);background:var(--tui-elevation-02);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-04);box-sizing:border-box;max-width:calc(100vw - 8px);isolation:isolate;pointer-events:auto}.ng-animating[_nghost-%COMP%]{pointer-events:none}[_nghost-%COMP%]:not([style*=\\\"top\\\"]){visibility:hidden}[data-mode=onDark][_nghost-%COMP%]{--tui-text-01: var(--tui-text-01-night);--tui-clear: var(--tui-clear-inverse);background:#222;border:1px solid #808080}.t-scroll[_ngcontent-%COMP%]{flex-grow:1;max-width:100%}.t-primitive[_ngcontent-%COMP%]{padding:1rem}\"],\n    data: {\n      animation: [tuiDropdownAnimation]\n    }\n  });\n  return TuiDropdownComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction activeZoneFilter(target) {\n  return !this.activeZone.contains(target);\n}\nconst TAP_DELAY = 700;\nconst MOVE_THRESHOLD = 15;\nlet TuiDropdownContextDirective = /*#__PURE__*/(() => {\n  class TuiDropdownContextDirective extends TuiDriver {\n    constructor(activeZone, isIOS, isTouch) {\n      super(subscriber => this.stream$.subscribe(subscriber));\n      this.activeZone = activeZone;\n      this.isIOS = isIOS;\n      this.isTouch = isTouch;\n      this.stream$ = new Subject();\n      this.currentRect = EMPTY_CLIENT_RECT;\n      this.longTapTimeout = NaN;\n      this.type = 'dropdown';\n    }\n    get userSelect() {\n      return this.isTouch ? 'none' : null;\n    }\n    onContextMenu(x, y) {\n      this.currentRect = tuiPointToClientRect(x, y);\n      this.stream$.next(true);\n    }\n    closeDropdown() {\n      this.stream$.next(false);\n      this.currentRect = EMPTY_CLIENT_RECT;\n    }\n    onTouchMove(x, y) {\n      if (this.isIOS && this.isTouch && this.currentRect !== EMPTY_CLIENT_RECT && Math.hypot(x - this.currentRect.x, y - this.currentRect.y) > MOVE_THRESHOLD) {\n        this.onTouchEnd();\n      }\n    }\n    onTouchStart(x, y) {\n      if (!this.isIOS || !this.isTouch || this.currentRect !== EMPTY_CLIENT_RECT) {\n        return;\n      }\n      this.longTapTimeout = setTimeout(() => {\n        this.currentRect = tuiPointToClientRect(x, y);\n        this.stream$.next(true);\n      }, TAP_DELAY);\n    }\n    onTouchEnd() {\n      if (this.isIOS && this.isTouch) {\n        clearTimeout(this.longTapTimeout);\n      }\n    }\n    getClientRect() {\n      return this.currentRect;\n    }\n  }\n  TuiDropdownContextDirective.ɵfac = function TuiDropdownContextDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownContextDirective)(i0.ɵɵdirectiveInject(TuiActiveZoneDirective), i0.ɵɵdirectiveInject(TUI_IS_IOS), i0.ɵɵdirectiveInject(TUI_IS_TOUCH));\n  };\n  TuiDropdownContextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownContextDirective,\n    selectors: [[\"\", \"tuiDropdown\", \"\", \"tuiDropdownContext\", \"\"]],\n    hostVars: 6,\n    hostBindings: function TuiDropdownContextDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"contextmenu.prevent.stop\", function TuiDropdownContextDirective_contextmenu_prevent_stop_HostBindingHandler($event) {\n          return ctx.onContextMenu($event.clientX, $event.clientY);\n        })(\"click.silent\", function TuiDropdownContextDirective_click_silent_HostBindingHandler($event) {\n          return ctx.closeDropdown($event.target);\n        }, i0.ɵɵresolveDocument)(\"contextmenu.capture.silent\", function TuiDropdownContextDirective_contextmenu_capture_silent_HostBindingHandler($event) {\n          return ctx.closeDropdown($event.target);\n        }, i0.ɵɵresolveDocument)(\"keydown.esc\", function TuiDropdownContextDirective_keydown_esc_HostBindingHandler($event) {\n          return ctx.closeDropdown($event.currentTarget);\n        }, i0.ɵɵresolveDocument)(\"pointerdown.silent\", function TuiDropdownContextDirective_pointerdown_silent_HostBindingHandler($event) {\n          return ctx.closeDropdown($event.target);\n        }, i0.ɵɵresolveDocument)(\"touchmove.silent.passive\", function TuiDropdownContextDirective_touchmove_silent_passive_HostBindingHandler($event) {\n          return ctx.onTouchMove($event.touches[0].clientX, $event.touches[0].clientY);\n        })(\"touchstart.silent.passive\", function TuiDropdownContextDirective_touchstart_silent_passive_HostBindingHandler($event) {\n          return ctx.onTouchStart($event.touches[0].clientX, $event.touches[0].clientY);\n        })(\"touchend.silent.passive\", function TuiDropdownContextDirective_touchend_silent_passive_HostBindingHandler() {\n          return ctx.onTouchEnd();\n        })(\"touchcancel.silent.passive\", function TuiDropdownContextDirective_touchcancel_silent_passive_HostBindingHandler() {\n          return ctx.onTouchEnd();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"user-select\", ctx.userSelect)(\"-webkit-touch-callout\", ctx.userSelect)(\"-webkit-user-select\", ctx.userSelect);\n      }\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([TuiActiveZoneDirective, tuiAsDriver(TuiDropdownContextDirective), tuiAsRectAccessor(TuiDropdownContextDirective)]), i0.ɵɵInheritDefinitionFeature]\n  });\n  __decorate([shouldCall(activeZoneFilter)], TuiDropdownContextDirective.prototype, \"closeDropdown\", null);\n  return TuiDropdownContextDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownDriverDirective = /*#__PURE__*/(() => {\n  class TuiDropdownDriverDirective extends AbstractTuiDriverDirective {\n    // TODO: Figure out why this is necessary under nx test runner\n    constructor(destroy$, drivers, vehicles) {\n      super(destroy$, drivers, vehicles);\n      this.type = 'dropdown';\n    }\n  }\n  TuiDropdownDriverDirective.ɵfac = function TuiDropdownDriverDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownDriverDirective)(i0.ɵɵdirectiveInject(TuiDestroyService, 2), i0.ɵɵdirectiveInject(TuiDriver), i0.ɵɵdirectiveInject(TuiVehicle));\n  };\n  TuiDropdownDriverDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownDriverDirective,\n    selectors: [[\"\", \"tuiDropdown\", \"\"]],\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([TuiDestroyService]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiDropdownDriverDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownHostDirective = /*#__PURE__*/(() => {\n  class TuiDropdownHostDirective extends TuiRectAccessor {\n    constructor() {\n      super(...arguments);\n      this.type = 'dropdown';\n    }\n    getClientRect() {\n      var _a;\n      return ((_a = this.tuiDropdownHost) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || EMPTY_CLIENT_RECT;\n    }\n  }\n  TuiDropdownHostDirective.ɵfac = /* @__PURE__ */(() => {\n    let ɵTuiDropdownHostDirective_BaseFactory;\n    return function TuiDropdownHostDirective_Factory(__ngFactoryType__) {\n      return (ɵTuiDropdownHostDirective_BaseFactory || (ɵTuiDropdownHostDirective_BaseFactory = i0.ɵɵgetInheritedFactory(TuiDropdownHostDirective)))(__ngFactoryType__ || TuiDropdownHostDirective);\n    };\n  })();\n  TuiDropdownHostDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownHostDirective,\n    selectors: [[\"\", \"tuiDropdown\", \"\", \"tuiDropdownHost\", \"\"]],\n    inputs: {\n      tuiDropdownHost: \"tuiDropdownHost\"\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([tuiAsRectAccessor(TuiDropdownHostDirective)]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiDropdownHostDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownManualDirective = /*#__PURE__*/(() => {\n  class TuiDropdownManualDirective extends TuiDriver {\n    constructor() {\n      super(subscriber => this.stream$.subscribe(subscriber));\n      this.stream$ = new BehaviorSubject(false);\n      this.tuiDropdownManual = false;\n      this.type = 'dropdown';\n    }\n    ngOnChanges() {\n      this.stream$.next(this.tuiDropdownManual);\n    }\n  }\n  TuiDropdownManualDirective.ɵfac = function TuiDropdownManualDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownManualDirective)();\n  };\n  TuiDropdownManualDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownManualDirective,\n    selectors: [[\"\", \"tuiDropdown\", \"\", \"tuiDropdownManual\", \"\"]],\n    inputs: {\n      tuiDropdownManual: \"tuiDropdownManual\"\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([tuiAsDriver(TuiDropdownManualDirective)]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return TuiDropdownManualDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownPositionSidedDirective = /*#__PURE__*/(() => {\n  class TuiDropdownPositionSidedDirective extends TuiPositionAccessor {\n    constructor(options, viewport, vertical) {\n      super();\n      this.options = options;\n      this.viewport = viewport;\n      this.vertical = vertical;\n      this.previous = this.options.direction || 'bottom';\n      this.tuiDropdownSided = '';\n      this.tuiDropdownSidedOffset = 4;\n      this.type = 'dropdown';\n    }\n    getPosition(rect) {\n      var _a, _b;\n      if (this.tuiDropdownSided === false) {\n        return this.vertical.getPosition(rect);\n      }\n      const {\n        height,\n        width\n      } = rect;\n      const hostRect = (_b = (_a = this.vertical.accessor) === null || _a === void 0 ? void 0 : _a.getClientRect()) !== null && _b !== void 0 ? _b : EMPTY_CLIENT_RECT;\n      const viewport = this.viewport.getClientRect();\n      const {\n        direction,\n        minHeight,\n        offset\n      } = this.options;\n      const align = this.options.align === 'center' ? 'left' : this.options.align;\n      const available = {\n        top: hostRect.bottom - viewport.top,\n        left: hostRect.left - offset - viewport.left,\n        right: viewport.right - hostRect.right - offset,\n        bottom: viewport.bottom - hostRect.top\n      };\n      const position = {\n        top: hostRect.bottom - height + this.tuiDropdownSidedOffset + 1,\n        left: hostRect.left - width - offset,\n        right: hostRect.right + offset,\n        bottom: hostRect.top - this.tuiDropdownSidedOffset - 1 // 1 for border\n      };\n      const better = available.top > available.bottom ? 'top' : 'bottom';\n      const maxLeft = available.left > available.right ? position.left : position.right;\n      const left = available[align] > width ? position[align] : maxLeft;\n      if (available[this.previous] > minHeight && direction || this.previous === better) {\n        return [position[this.previous], left];\n      }\n      this.previous = better;\n      return [position[better], left];\n    }\n  }\n  TuiDropdownPositionSidedDirective.ɵfac = function TuiDropdownPositionSidedDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownPositionSidedDirective)(i0.ɵɵdirectiveInject(TUI_DROPDOWN_OPTIONS), i0.ɵɵdirectiveInject(TUI_VIEWPORT), i0.ɵɵdirectiveInject(TuiDropdownPositionDirective));\n  };\n  TuiDropdownPositionSidedDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownPositionSidedDirective,\n    selectors: [[\"\", \"tuiDropdownSided\", \"\"]],\n    inputs: {\n      tuiDropdownSided: \"tuiDropdownSided\",\n      tuiDropdownSidedOffset: \"tuiDropdownSidedOffset\"\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([TuiDropdownPositionDirective, tuiAsPositionAccessor(TuiDropdownPositionSidedDirective)]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiDropdownPositionSidedDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownSelectionDirective = /*#__PURE__*/(() => {\n  class TuiDropdownSelectionDirective extends TuiDriver {\n    constructor(range, doc, selection$, el, vcr, dropdown) {\n      super(subscriber => this.stream$.subscribe(subscriber));\n      this.range = range;\n      this.doc = doc;\n      this.selection$ = selection$;\n      this.el = el;\n      this.vcr = vcr;\n      this.dropdown = dropdown;\n      this.handler$ = new BehaviorSubject(ALWAYS_TRUE_HANDLER);\n      this.stream$ = combineLatest([this.handler$, this.selection$.pipe(map(() => this.getRange()), distinctUntilChanged((x, y) => x.startOffset === y.startOffset && x.endOffset === y.endOffset && x.commonAncestorContainer === y.commonAncestorContainer))]).pipe(map(([handler, range]) => {\n        const contained = this.el.nativeElement.contains(range.commonAncestorContainer);\n        this.range = contained && tuiIsTextNode(range.commonAncestorContainer) ? range : this.range;\n        return contained && handler(this.range) || this.inDropdown(range);\n      }));\n      this.position = 'selection';\n      this.type = 'dropdown';\n    }\n    set tuiDropdownSelection(visible) {\n      if (!tuiIsString(visible)) {\n        this.handler$.next(visible);\n      }\n    }\n    getClientRect() {\n      switch (this.position) {\n        case 'tag':\n          {\n            const {\n              commonAncestorContainer\n            } = this.range;\n            const element = tuiIsElement(commonAncestorContainer) ? commonAncestorContainer : commonAncestorContainer.parentNode;\n            return element && tuiIsElement(element) ? element.getBoundingClientRect() : EMPTY_CLIENT_RECT;\n          }\n        case 'word':\n          return tuiGetWordRange(this.range).getBoundingClientRect();\n        default:\n          return this.range.getBoundingClientRect();\n      }\n    }\n    ngOnDestroy() {\n      if (this.ghost) {\n        this.vcr.element.nativeElement.removeChild(this.ghost);\n      }\n    }\n    getRange() {\n      const active = tuiGetNativeFocused(this.doc);\n      const selection = this.doc.getSelection();\n      const range = active && tuiIsTextfield(active) && this.el.nativeElement.contains(active) ? this.veryVerySadInputFix(active) : (selection === null || selection === void 0 ? void 0 : selection.rangeCount) && selection.getRangeAt(0) || this.range;\n      return range.cloneRange();\n    }\n    /**\n     * Check if given range is at least partially inside dropdown\n     */\n    inDropdown(range) {\n      const {\n        startContainer,\n        endContainer\n      } = range;\n      const {\n        nativeElement\n      } = this.el;\n      const inDropdown = this.boxContains(range.commonAncestorContainer);\n      const hostToDropdown = this.boxContains(endContainer) && nativeElement.contains(startContainer);\n      const dropdownToHost = this.boxContains(startContainer) && nativeElement.contains(endContainer);\n      return inDropdown || hostToDropdown || dropdownToHost;\n    }\n    veryVerySadInputFix(element) {\n      const {\n        ghost = this.initGhost(element)\n      } = this;\n      const {\n        top,\n        left,\n        width,\n        height\n      } = element.getBoundingClientRect();\n      const {\n        selectionStart,\n        selectionEnd,\n        value\n      } = element;\n      const range = this.doc.createRange();\n      const hostRect = this.el.nativeElement.getBoundingClientRect();\n      ghost.style.top = tuiPx(top - hostRect.top);\n      ghost.style.left = tuiPx(left - hostRect.left);\n      ghost.style.width = tuiPx(width);\n      ghost.style.height = tuiPx(height);\n      ghost.textContent = CHAR_ZERO_WIDTH_SPACE + value + CHAR_NO_BREAK_SPACE;\n      range.setStart(ghost.firstChild, selectionStart || 0);\n      range.setEnd(ghost.firstChild, selectionEnd || 0);\n      return range;\n    }\n    /**\n     * Check if Node is inside dropdown\n     */\n    boxContains(node) {\n      var _a;\n      return !!((_a = this.dropdown.dropdownBoxRef) === null || _a === void 0 ? void 0 : _a.location.nativeElement.contains(node));\n    }\n    /**\n     * Create an invisible DIV styled exactly like input/textarea element inside directive\n     */\n    initGhost(element) {\n      const ghost = this.doc.createElement('div');\n      const {\n        font,\n        letterSpacing,\n        textTransform,\n        padding\n      } = getComputedStyle(element);\n      ghost.style.position = 'absolute';\n      ghost.style.pointerEvents = 'none';\n      ghost.style.opacity = '0';\n      ghost.style.whiteSpace = 'pre-wrap';\n      ghost.style.font = font;\n      ghost.style.letterSpacing = letterSpacing;\n      ghost.style.textTransform = textTransform;\n      ghost.style.padding = padding;\n      this.vcr.element.nativeElement.appendChild(ghost);\n      this.ghost = ghost;\n      return ghost;\n    }\n  }\n  TuiDropdownSelectionDirective.ɵfac = function TuiDropdownSelectionDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownSelectionDirective)(i0.ɵɵdirectiveInject(TUI_RANGE), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(TUI_SELECTION_STREAM), i0.ɵɵdirectiveInject(ElementRef), i0.ɵɵdirectiveInject(ViewContainerRef), i0.ɵɵdirectiveInject(TuiDropdownDirective));\n  };\n  TuiDropdownSelectionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TuiDropdownSelectionDirective,\n    selectors: [[\"\", \"tuiDropdown\", \"\", \"tuiDropdownSelection\", \"\"]],\n    inputs: {\n      position: [0, \"tuiDropdownSelectionPosition\", \"position\"],\n      tuiDropdownSelection: \"tuiDropdownSelection\"\n    },\n    standalone: false,\n    features: [i0.ɵɵProvidersFeature([tuiAsDriver(TuiDropdownSelectionDirective), tuiAsRectAccessor(TuiDropdownSelectionDirective)]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return TuiDropdownSelectionDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TuiDropdownModule = /*#__PURE__*/(() => {\n  class TuiDropdownModule {}\n  TuiDropdownModule.ɵfac = function TuiDropdownModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TuiDropdownModule)();\n  };\n  TuiDropdownModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TuiDropdownModule\n  });\n  TuiDropdownModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[PolymorpheusModule, TuiActiveZoneModule, TuiOverscrollModule, TuiScrollbarModule, TuiHoveredModule]]\n  });\n  return TuiDropdownModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { TUI_DROPDOWN_COMPONENT, TUI_DROPDOWN_DEFAULT_OPTIONS, TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS, TUI_DROPDOWN_HOVER_OPTIONS, TUI_DROPDOWN_OPTIONS, TuiDropdownComponent, TuiDropdownContextDirective, TuiDropdownDirective, TuiDropdownDriverDirective, TuiDropdownHostDirective, TuiDropdownHoverDirective, TuiDropdownManualDirective, TuiDropdownModule, TuiDropdownOpenDirective, TuiDropdownOptionsDirective, TuiDropdownPositionDirective, TuiDropdownPositionSidedDirective, TuiDropdownSelectionDirective, tuiDropdownHoverOptionsProvider, tuiDropdownOptionsProvider };\n//# sourceMappingURL=taiga-ui-core-directives-dropdown.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}